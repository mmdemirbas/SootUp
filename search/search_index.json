{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is SootUp? The purpose of the SootUp project is to make Soot future-proof. The focus of this project lies on restructuring Soot away from a framework that makes heavy use of singletons, towards a lighter library that can easily be included in other projects. Click here to read our announcement on the first release of SootUp Important SootUp is not a version update to Soot, it is instead a completely new implementation written from scratch that aims to be a leaner, more extensible equivalent of soot. What is new? Over the years, Soot has evolved into a powerful framework, which is one of the most widely used tools in the static analysis community. This evolution was guided by the needs of the community and carried out with ad-hoc improvements. As a result, Soot has become a tool that can do many things, but it is heavy and hard to maintain. Below are the features of SootUp, which aims to address Soot's shortcomings. Library by default Soot can do many things. It is a library and a stand-alone command-line application. SootUp, on the other hand, is designed to be a core library. It assumes that it is embedded in a client application that owns the thread of control. It can be extended with a command-line interface, included in other software projects as a library, or integrated into IDEs with JimpleLSP . Modular Architecture SootUp has a modular architecture, which enables its clients to include only the necessary functionality to their applications. Below are its modules: core core module contains the core building blocks such as the jimple IR, control flow graphs, and frontend interfaces. The rest of the modules build on the core module. java.core java.core module contains parts that are essential for analyzing Java code. java.bytecode java.bytecode module contains the functionality that is necessary for taking as input java bytecode. java.sourcecode java.sourcecode module contains the functionality that is necessary for taking as input java source code. callgraph callgraph module contains implementations of common call graph construction algorithms such as CHA , RTA . A reimplementation of Spark pointer analysis framework is in progress. jimple.parser jimple.parser module contains the functionalty that is necessary for taking as input .jimple files. analysis analysis module enables performing interprocedural dataflow analyses. No More Singletons Singletons offer a single view of a single program version, which makes it impossible to analyze multiple programs or multiple versions of the same program. SootUp does not make use of singletons such the Scene class in the old Soot any more. It enables analyzing multple programs simultaneously. New Source Code Frontend Soot's JastAdd-based java frontend is not maintained anymore. In SootUp, we use WALA's well-maintained source code frontend, which will not only allow Soot to analyze Java source code, but also JavaScript and Python. Immutable by Design SootUp has been designed with the goal of immutability in mind. This makes sharing objects between several entities easier, because there is no need to worry about unintended changes to other entities. Withers instead of Setters Due to the immutability goal, many classes do not have setters anymore. For example, a Body does not have a method setStmts(List<Stmt> stmts) . Instead, a method called withStmts(List<Stmt> stmts) has been added. This does not modify the original instance, but returns a copy that has different stmts than the original instance. This concept of so-called with -ers can be found all throughout SootUp. A simplified example 1 2 3 4 5 6 7 8 9 10 11 12 class Body { final List < Stmt > stmts ; final List < Local > locals ; Body ( List < Stmt > stmts , List < Local > locals ) { this . stmts = stmts ; this . locals = locals ; } Body withStmts ( List < Stmt > stmts ) { return new Body ( stmts , this . locals ); } Body withLocals ( List < Local > locals ) { return new Body ( this . stmts , locals ); } } Intermediate Representation Jimple is the only intermediate representation (IR) in SootUp. We changed it slightly to be able to accommodate different programming languages in future. Is this a drop-in replacement for Soot? Not really. SootUp has a completely new architecture and API, so it is not trivial to update existing projects that build on soot. We recommend using it for greenfield projects. Supporters The development of SootUp is financed by generous support from the German Research Foundation (DFG), the Heinz Nixdorf Institute (HNI). Become a sponsor!","title":"Home"},{"location":"#what-is-sootup","text":"The purpose of the SootUp project is to make Soot future-proof. The focus of this project lies on restructuring Soot away from a framework that makes heavy use of singletons, towards a lighter library that can easily be included in other projects.","title":"What is SootUp?"},{"location":"#click-here-to-read-our-announcement-on-the-first-release-of-sootup","text":"Important SootUp is not a version update to Soot, it is instead a completely new implementation written from scratch that aims to be a leaner, more extensible equivalent of soot.","title":"Click here to read our announcement on the first release of SootUp"},{"location":"#what-is-new","text":"Over the years, Soot has evolved into a powerful framework, which is one of the most widely used tools in the static analysis community. This evolution was guided by the needs of the community and carried out with ad-hoc improvements. As a result, Soot has become a tool that can do many things, but it is heavy and hard to maintain. Below are the features of SootUp, which aims to address Soot's shortcomings.","title":"What is new?"},{"location":"#library-by-default","text":"Soot can do many things. It is a library and a stand-alone command-line application. SootUp, on the other hand, is designed to be a core library. It assumes that it is embedded in a client application that owns the thread of control. It can be extended with a command-line interface, included in other software projects as a library, or integrated into IDEs with JimpleLSP .","title":"Library by default"},{"location":"#modular-architecture","text":"SootUp has a modular architecture, which enables its clients to include only the necessary functionality to their applications. Below are its modules: core core module contains the core building blocks such as the jimple IR, control flow graphs, and frontend interfaces. The rest of the modules build on the core module. java.core java.core module contains parts that are essential for analyzing Java code. java.bytecode java.bytecode module contains the functionality that is necessary for taking as input java bytecode. java.sourcecode java.sourcecode module contains the functionality that is necessary for taking as input java source code. callgraph callgraph module contains implementations of common call graph construction algorithms such as CHA , RTA . A reimplementation of Spark pointer analysis framework is in progress. jimple.parser jimple.parser module contains the functionalty that is necessary for taking as input .jimple files. analysis analysis module enables performing interprocedural dataflow analyses.","title":"Modular Architecture"},{"location":"#no-more-singletons","text":"Singletons offer a single view of a single program version, which makes it impossible to analyze multiple programs or multiple versions of the same program. SootUp does not make use of singletons such the Scene class in the old Soot any more. It enables analyzing multple programs simultaneously.","title":"No More Singletons"},{"location":"#new-source-code-frontend","text":"Soot's JastAdd-based java frontend is not maintained anymore. In SootUp, we use WALA's well-maintained source code frontend, which will not only allow Soot to analyze Java source code, but also JavaScript and Python.","title":"New Source Code Frontend"},{"location":"#immutable-by-design","text":"SootUp has been designed with the goal of immutability in mind. This makes sharing objects between several entities easier, because there is no need to worry about unintended changes to other entities.","title":"Immutable by Design"},{"location":"#withers-instead-of-setters","text":"Due to the immutability goal, many classes do not have setters anymore. For example, a Body does not have a method setStmts(List<Stmt> stmts) . Instead, a method called withStmts(List<Stmt> stmts) has been added. This does not modify the original instance, but returns a copy that has different stmts than the original instance. This concept of so-called with -ers can be found all throughout SootUp. A simplified example 1 2 3 4 5 6 7 8 9 10 11 12 class Body { final List < Stmt > stmts ; final List < Local > locals ; Body ( List < Stmt > stmts , List < Local > locals ) { this . stmts = stmts ; this . locals = locals ; } Body withStmts ( List < Stmt > stmts ) { return new Body ( stmts , this . locals ); } Body withLocals ( List < Local > locals ) { return new Body ( this . stmts , locals ); } }","title":"Withers instead of Setters"},{"location":"#intermediate-representation","text":"Jimple is the only intermediate representation (IR) in SootUp. We changed it slightly to be able to accommodate different programming languages in future.","title":"Intermediate Representation"},{"location":"#is-this-a-drop-in-replacement-for-soot","text":"Not really. SootUp has a completely new architecture and API, so it is not trivial to update existing projects that build on soot. We recommend using it for greenfield projects.","title":"Is this a drop-in replacement for Soot?"},{"location":"#supporters","text":"The development of SootUp is financed by generous support from the German Research Foundation (DFG), the Heinz Nixdorf Institute (HNI). Become a sponsor!","title":"Supporters"},{"location":"advanced-topics/","text":"Advanced Topics As a user of the SootUp framework, you can omit these topics which mostly explain how some of the concepts work internally. Body Interceptors Soot Equivalent BodyTransformer Almost in all use-cases you can simply ignore body interceptors. They are applied to each Body by default to create their rather normalized or leaner versions, e.g. by eliminating unreachable code ( UnreachableCodeEliminator ), standardizing names of locals ( LocalNameStandardizer ), or removing empty switch statements ( EmptySwitchEliminator ) etc. Below, we show how these body interceptors work for the users who are interested in their internal workings. LocalSplitter LocalSplitter is a BodyInterceptor that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables. Example 1: As shown in the example above, the local variable l1 is defined twice. It can be split up into two new local variables: l1#1 and l1#2 because the both definitions are independent of each other. Look for foldable navigation and tabs for showing old vs new Example 2: In the second example, the local variable l2 is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure. LocalPacker LocalPacker is a BodyInterceptor that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker. Example: In the given example above, the local variables l1 , l3 are summarized to be one local variable l1 , because they have the same type without interference with each other. Likewise, the local variables l2 , l4 and l5 are summarized to be another local variable l2 . Although the local variable l0 doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type. TrapTightener TrapTightener is a BodyInterceptor that shrinks the protected area covered by each Trap in a Body. Example: We assume in the example above that only the Stmt : l2 := 2 might throw an exception caught by the Trap which is labeled with label3 . In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three Stmts : l1 := 1; l2 := 2; l2 := 3 . But an exception could only arise at the Stmt : l2 := 2 . After the implementation of TrapTightener, we will get a contractible protected area which contains only the Stmt that might throw an exception, namely the Stmt : l2 := 2 . EmptySwitchEliminator EmptySwitchEliminator is a BodyInterceptor that removes empty switch statements which contain only the default case. Example: As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a GotoStmt to the default case. UnreachableCodeEliminator UnreachableCodeEliminator is a BodyInterceptor that removes all unreachable statements. Example: Obviously, the code segment l2 = 2; l3 = 3; is unreachable. It will be removed after running the UreachableCodeEliminator. CopyPropagator CopyPropagator is a BodyInterceptor that supports the global copy propagation and constant propagation. Example for global copy propagation: Consider a code segment in the following form: 1 2 3 a = b; ... c = use(a); // a, b, c are local variables According to the copy propagation's definition, the statement c = use(a) can be replaced with c = use(b) iff both conditions are met: a is defined only one time on all the paths from a = b to c = use(a) . There are no definitions of b on any path from a = b to c = use(a) . In the example for global copy propagation, the first used l1 is replaced with l0 , but the second used l1 cannot be replaced with l3 , because the second condition is not satisfied. Example for constant propagation: Constant propagation is similar to copy propagation. Consider a code segment in the following form: 1 2 3 a = const; ... b = use(a); // a, b are local variables, const is a constant After perfoming the constant propagation, the statement b = use(a) can be replaced with b = use(const) iff a is not redefined on any of the paths from a = const to b = use(a) . Therefore, the first used l1 in the second example can be replaced with the constant 1 , but the second used l1 cannot be replaced with the constant 2 , because l1 is redefined on the path from l1 = 2 to l4 = use(l1) . However, it can be replaced with local variable l2 , because the both conditions of copy propagation are met. LocalNameStandardizer LocalNameStandardizer is a BodyInterceptor that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order. Each assigned name consists of two parts: A letter to imply the local variable's type A digit to imply the local variable's order The following table shows the letter corresponding to each type: Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r StaticSingleAssignmentFormer StaticSingleAssignmentFormer is a BodyInterceptor that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use. Example: In the given example, the StaticSingleAssignmentFormer assigns each IdentityStmt and AssignStmt to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a PhiStmt in the front of the join block to merge all most recently defined local variables and assign them a new local variable. Tools LocalLivenessAnalyser LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given Stmt . Example: The live local variables before and after each Stmt will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods getLiveLocalsBeforeStmt and getLiveLocalsAfterStmt . DominanceFinder DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block. Example: After generating an instance of DominanceFinder for a BlockGraph , we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods getImmediateDominator and getDominanceFrontiers .","title":"Advanced Topics"},{"location":"advanced-topics/#advanced-topics","text":"As a user of the SootUp framework, you can omit these topics which mostly explain how some of the concepts work internally.","title":"Advanced Topics"},{"location":"advanced-topics/#body-interceptors","text":"Soot Equivalent BodyTransformer Almost in all use-cases you can simply ignore body interceptors. They are applied to each Body by default to create their rather normalized or leaner versions, e.g. by eliminating unreachable code ( UnreachableCodeEliminator ), standardizing names of locals ( LocalNameStandardizer ), or removing empty switch statements ( EmptySwitchEliminator ) etc. Below, we show how these body interceptors work for the users who are interested in their internal workings.","title":"Body Interceptors"},{"location":"advanced-topics/#localsplitter","text":"LocalSplitter is a BodyInterceptor that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables. Example 1: As shown in the example above, the local variable l1 is defined twice. It can be split up into two new local variables: l1#1 and l1#2 because the both definitions are independent of each other. Look for foldable navigation and tabs for showing old vs new Example 2: In the second example, the local variable l2 is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure.","title":"LocalSplitter"},{"location":"advanced-topics/#localpacker","text":"LocalPacker is a BodyInterceptor that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker. Example: In the given example above, the local variables l1 , l3 are summarized to be one local variable l1 , because they have the same type without interference with each other. Likewise, the local variables l2 , l4 and l5 are summarized to be another local variable l2 . Although the local variable l0 doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type.","title":"LocalPacker"},{"location":"advanced-topics/#traptightener","text":"TrapTightener is a BodyInterceptor that shrinks the protected area covered by each Trap in a Body. Example: We assume in the example above that only the Stmt : l2 := 2 might throw an exception caught by the Trap which is labeled with label3 . In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three Stmts : l1 := 1; l2 := 2; l2 := 3 . But an exception could only arise at the Stmt : l2 := 2 . After the implementation of TrapTightener, we will get a contractible protected area which contains only the Stmt that might throw an exception, namely the Stmt : l2 := 2 .","title":"TrapTightener"},{"location":"advanced-topics/#emptyswitcheliminator","text":"EmptySwitchEliminator is a BodyInterceptor that removes empty switch statements which contain only the default case. Example: As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a GotoStmt to the default case.","title":"EmptySwitchEliminator"},{"location":"advanced-topics/#unreachablecodeeliminator","text":"UnreachableCodeEliminator is a BodyInterceptor that removes all unreachable statements. Example: Obviously, the code segment l2 = 2; l3 = 3; is unreachable. It will be removed after running the UreachableCodeEliminator.","title":"UnreachableCodeEliminator"},{"location":"advanced-topics/#copypropagator","text":"CopyPropagator is a BodyInterceptor that supports the global copy propagation and constant propagation. Example for global copy propagation: Consider a code segment in the following form: 1 2 3 a = b; ... c = use(a); // a, b, c are local variables According to the copy propagation's definition, the statement c = use(a) can be replaced with c = use(b) iff both conditions are met: a is defined only one time on all the paths from a = b to c = use(a) . There are no definitions of b on any path from a = b to c = use(a) . In the example for global copy propagation, the first used l1 is replaced with l0 , but the second used l1 cannot be replaced with l3 , because the second condition is not satisfied. Example for constant propagation: Constant propagation is similar to copy propagation. Consider a code segment in the following form: 1 2 3 a = const; ... b = use(a); // a, b are local variables, const is a constant After perfoming the constant propagation, the statement b = use(a) can be replaced with b = use(const) iff a is not redefined on any of the paths from a = const to b = use(a) . Therefore, the first used l1 in the second example can be replaced with the constant 1 , but the second used l1 cannot be replaced with the constant 2 , because l1 is redefined on the path from l1 = 2 to l4 = use(l1) . However, it can be replaced with local variable l2 , because the both conditions of copy propagation are met.","title":"CopyPropagator"},{"location":"advanced-topics/#localnamestandardizer","text":"LocalNameStandardizer is a BodyInterceptor that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order. Each assigned name consists of two parts: A letter to imply the local variable's type A digit to imply the local variable's order The following table shows the letter corresponding to each type: Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r","title":"LocalNameStandardizer"},{"location":"advanced-topics/#staticsingleassignmentformer","text":"StaticSingleAssignmentFormer is a BodyInterceptor that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use. Example: In the given example, the StaticSingleAssignmentFormer assigns each IdentityStmt and AssignStmt to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a PhiStmt in the front of the join block to merge all most recently defined local variables and assign them a new local variable.","title":"StaticSingleAssignmentFormer"},{"location":"advanced-topics/#tools","text":"","title":"Tools"},{"location":"advanced-topics/#locallivenessanalyser","text":"LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given Stmt . Example: The live local variables before and after each Stmt will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods getLiveLocalsBeforeStmt and getLiveLocalsAfterStmt .","title":"LocalLivenessAnalyser"},{"location":"advanced-topics/#dominancefinder","text":"DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block. Example: After generating an instance of DominanceFinder for a BlockGraph , we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods getImmediateDominator and getDominanceFrontiers .","title":"DominanceFinder"},{"location":"announce/","text":"We would like to announce Soot \u2019s successor, SootUp. Over more than 20 years, Soot has become one of the world\u2019s most popular academic tool for Java and Android analysis and instrumentation. We thank all of you who have used and contributed to it over the years! It was your feedback and your contributions that helped it grow into such a versatile tool! However, over the years, the requirements for Soot have changed a lot, and given its original architecture, it was no longer quite up to the task. Soot was originally developed for ahead-of-time code transformation, particularly optimization, which has become very uncommon in Java. Current use cases center much more around powerful program analyses and program-understanding tasks. Today we are officially releasing SootUp, a new version of Soot with a completely overhauled architecture. With SootUp, we aim to keep the best things about Soot, yet overcome a lot of its drawbacks. We very much restructured Soot, particularly abolishing the heavy use of singletons. Soot now has a concept of views; each view corresponds to some version or variant of an analyzed program, and multiple views can be kept in memory at the same time. This sets the foundation, for instance, for differential or incremental program analyses. SootUp is a library that can easily be included in other projects, leaving those projects in control. For those who intend to use it as a framework, with inversion of control, SootUp provides additional templates that help you and novices to get started more easily. The Jimple IR has been slightly simplified, and has been made immutable by default such that internally SootUp can make use of caching where desired. Where required, Jimple transformations are still allowed, but in a systematic manner, for instance assuring that analyses depending on the transformed code are notified about its changes. Below is an overview of what\u2019s new. Library by default, framework as an option Modular Architecture, no more singletons New source code frontend Immutable Jimple IR Greatly increased testability and test coverage SootUp is not a drop-in replacement for Soot! Due to its completely new architecture and API it is essentially an almost complete rewrite. For a while, Soot and SootUp will coexist, as many existing tools depend on Soot, yet our maintenance efforts will henceforth be focused on SootUp, not Soot, and on extending SootUp with those capabilities that people still find missing. For now, we recommend using SootUp for greenfield projects. For more details, check out * The SootUp home page: https://soot-oss.github.io/SootUp/, and * The SootUp repository: https://github.com/soot-oss/SootUp/ We are very much looking forward to your feedback and feature requests. To this end, best create appropriate issues in the repository. This major upgrade of Soot was made possible by generous competitive funding by the DFG, within the project \u201cFuture-proofing the Soot Framework for Program Analysis and Transformation (FutureSoot)\u201d. It was funded in the DFG\u2019s program on Research Software Sustainability.","title":"Announce"},{"location":"call-graph-construction/","text":"Call Graph Construction A call graph shows the method calling relationship of a program. It is a directed graph, whose nodes represent different methods , and edges represent caller -> callee relationship. SootUp contains several call graph construction algorithms. Below, we show how you can use each of these. Creating the Type Hierarchy All the call graph construction algorithms require a type hierarchy for resolving method calls based of sub typing relationship. Below, we show how to create a type hierarchy: SootUp Soot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 AnalysisInputLocation < JavaSootClass > inputLocation = new JavaClassPathAnalysisInputLocation ( \"src/test/resources/Callgraph/binary\" ); JavaLanguage language = new JavaLanguage ( 8 ); JavaProject project = JavaProject . builder ( language ) . addInputLocation ( inputLocation ) . addInputLocation ( new JavaClassPathAnalysisInputLocation ( System . getProperty ( \"java.home\" ) + \"/lib/rt.jar\" )) . build (); JavaView view = project . createFullView (); ViewTypeHierarchy typeHierarchy = new ViewTypeHierarchy ( view ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String targetTestClassName = target . exercise1 . Hierarchy . class . getName (); G . reset (); String userdir = System . getProperty ( \"user.dir\" ); String sootCp = userdir + File . separator + \"target\" + File . separator + \"test-classes\" + File . pathSeparator + \"lib\" + File . separator + \"rt.jar\" ; Options . v (). set_whole_program ( true ); Options . v (). set_soot_classpath ( sootCp ); Options . v (). set_no_bodies_for_excluded ( true ); Options . v (). process_dir (); Options . v (). set_allow_phantom_refs ( true ); Options . v (). setPhaseOption ( \"jb\" , \"use-original-names:true\" ); Options . v (). set_prepend_classpath ( false ); SootClass c = Scene . v (). forceResolve ( targetTestClassName , SootClass . BODIES ); if ( c != null ) c . setApplicationClass (); Scene . v (). loadNecessaryClasses (); Hierarchy hierarchy = new Hierarchy (); Defining an Entry Method All the call graph construction algorithms require an entry method to start with. In java application, you usually define the main method. However, it is possible to define arbitrary entry methods depending on your needs. Below, we show how to define such an entry method: SootUp Soot 1 2 3 4 5 6 7 8 9 ClassType classTypeA = project . getIdentifierFactory (). getClassType ( \"A\" ); MethodSignature entryMethodSignature = JavaIdentifierFactory . getInstance () . getMethodSignature ( classTypeA , JavaIdentifierFactory . getInstance () . getMethodSubSignature ( \"calc\" , VoidType . getInstance (), Collections . singletonList ( classTypeA ))); 1 SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); Class Hierarchy Analysis Class Hierarchy Analysis (CHA) algorithm is the most sound call graph construction algorithm available in SootUp. It soundly includes all implementers of an interface, when resolving a method call on an interface. You can construct a call graph with CHA as follows: SootUp Soot 1 2 3 4 5 6 7 CallGraphAlgorithm cha = new ClassHierarchyAnalysisAlgorithm ( view , typeHierarchy ); CallGraph cg = cha . initialize ( Collections . singletonList ( entryMethodSignature )); cg . callsFrom ( entryMethodSignature ). forEach ( System . out :: println ); 1 2 3 4 5 6 7 8 CHATransformer . v (). transform (); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); } Rapid Type Analysis Rapid Type Analysis (RTA) algorithm constructs a rather precise version of the call graph that the CHA constructs. It refines CHA by considering only the instantiated implementers of an interface, when resolving a method call on an interface. You can construct a call graph with RTA as follows: SootUp Soot 1 2 3 4 5 6 7 CallGraphAlgorithm rta = new RapidTypeAnalysisAlgorithm ( view , typeHierarchy ); CallGraph cg = rta . initialize ( Collections . singletonList ( entryMethodSignature )); cg . callsFrom ( entryMethodSignature ). forEach ( System . out :: println ); 1 2 3 4 5 6 7 8 9 10 11 12 13 Transform sparkConfig = new Transform ( \"cg.spark\" , null ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"enabled:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"rta:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"on-fly-cg:false\" ); Map phaseOptions = PhaseOptions . v (). getPhaseOptions ( sparkConfig ); SparkTransformer . v (). transform ( sparkConfig . getPhaseName (), phaseOptions ); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); } Variable Type Analysis Variable Type Analysis (VTA) algorithm further refines the call graph that the RTA constructs. It refines RTA by considering only the assigned instantiations of the implementers of an interface, when resolving a method call on an interface. When considering assignments, we usually need to consider pointer (points-to) relationship. Info VTA algorithm was implemented using the Spark pointer analysis framework. A reimplementation of Spark in SootUp is currently under development. Spark requires an initial call graph to begin with. You can use one of the call graphs that we have constructed above. You can construct a call graph with VTA as follows: SootUp Soot 1 2 3 Spark spark = new Spark . Builder ( view , callGraph ). vta ( true ). build (); spark . analyze (); CallGraph vtaCAllGraph = spark . getCallGraph (); 1 2 3 4 5 6 7 8 9 10 11 12 13 Transform sparkConfig = new Transform ( \"cg.spark\" , null ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"enabled:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"vta:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"on-fly-cg:false\" ); Map phaseOptions = PhaseOptions . v (). getPhaseOptions ( sparkConfig ); SparkTransformer . v (). transform ( sparkConfig . getPhaseName (), phaseOptions ); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); }","title":"Call Graph Construction"},{"location":"call-graph-construction/#call-graph-construction","text":"A call graph shows the method calling relationship of a program. It is a directed graph, whose nodes represent different methods , and edges represent caller -> callee relationship. SootUp contains several call graph construction algorithms. Below, we show how you can use each of these.","title":"Call Graph Construction"},{"location":"call-graph-construction/#creating-the-type-hierarchy","text":"All the call graph construction algorithms require a type hierarchy for resolving method calls based of sub typing relationship. Below, we show how to create a type hierarchy: SootUp Soot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 AnalysisInputLocation < JavaSootClass > inputLocation = new JavaClassPathAnalysisInputLocation ( \"src/test/resources/Callgraph/binary\" ); JavaLanguage language = new JavaLanguage ( 8 ); JavaProject project = JavaProject . builder ( language ) . addInputLocation ( inputLocation ) . addInputLocation ( new JavaClassPathAnalysisInputLocation ( System . getProperty ( \"java.home\" ) + \"/lib/rt.jar\" )) . build (); JavaView view = project . createFullView (); ViewTypeHierarchy typeHierarchy = new ViewTypeHierarchy ( view ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String targetTestClassName = target . exercise1 . Hierarchy . class . getName (); G . reset (); String userdir = System . getProperty ( \"user.dir\" ); String sootCp = userdir + File . separator + \"target\" + File . separator + \"test-classes\" + File . pathSeparator + \"lib\" + File . separator + \"rt.jar\" ; Options . v (). set_whole_program ( true ); Options . v (). set_soot_classpath ( sootCp ); Options . v (). set_no_bodies_for_excluded ( true ); Options . v (). process_dir (); Options . v (). set_allow_phantom_refs ( true ); Options . v (). setPhaseOption ( \"jb\" , \"use-original-names:true\" ); Options . v (). set_prepend_classpath ( false ); SootClass c = Scene . v (). forceResolve ( targetTestClassName , SootClass . BODIES ); if ( c != null ) c . setApplicationClass (); Scene . v (). loadNecessaryClasses (); Hierarchy hierarchy = new Hierarchy ();","title":"Creating the Type Hierarchy"},{"location":"call-graph-construction/#defining-an-entry-method","text":"All the call graph construction algorithms require an entry method to start with. In java application, you usually define the main method. However, it is possible to define arbitrary entry methods depending on your needs. Below, we show how to define such an entry method: SootUp Soot 1 2 3 4 5 6 7 8 9 ClassType classTypeA = project . getIdentifierFactory (). getClassType ( \"A\" ); MethodSignature entryMethodSignature = JavaIdentifierFactory . getInstance () . getMethodSignature ( classTypeA , JavaIdentifierFactory . getInstance () . getMethodSubSignature ( \"calc\" , VoidType . getInstance (), Collections . singletonList ( classTypeA ))); 1 SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" );","title":"Defining an Entry Method"},{"location":"call-graph-construction/#class-hierarchy-analysis","text":"Class Hierarchy Analysis (CHA) algorithm is the most sound call graph construction algorithm available in SootUp. It soundly includes all implementers of an interface, when resolving a method call on an interface. You can construct a call graph with CHA as follows: SootUp Soot 1 2 3 4 5 6 7 CallGraphAlgorithm cha = new ClassHierarchyAnalysisAlgorithm ( view , typeHierarchy ); CallGraph cg = cha . initialize ( Collections . singletonList ( entryMethodSignature )); cg . callsFrom ( entryMethodSignature ). forEach ( System . out :: println ); 1 2 3 4 5 6 7 8 CHATransformer . v (). transform (); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); }","title":"Class Hierarchy Analysis"},{"location":"call-graph-construction/#rapid-type-analysis","text":"Rapid Type Analysis (RTA) algorithm constructs a rather precise version of the call graph that the CHA constructs. It refines CHA by considering only the instantiated implementers of an interface, when resolving a method call on an interface. You can construct a call graph with RTA as follows: SootUp Soot 1 2 3 4 5 6 7 CallGraphAlgorithm rta = new RapidTypeAnalysisAlgorithm ( view , typeHierarchy ); CallGraph cg = rta . initialize ( Collections . singletonList ( entryMethodSignature )); cg . callsFrom ( entryMethodSignature ). forEach ( System . out :: println ); 1 2 3 4 5 6 7 8 9 10 11 12 13 Transform sparkConfig = new Transform ( \"cg.spark\" , null ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"enabled:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"rta:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"on-fly-cg:false\" ); Map phaseOptions = PhaseOptions . v (). getPhaseOptions ( sparkConfig ); SparkTransformer . v (). transform ( sparkConfig . getPhaseName (), phaseOptions ); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); }","title":"Rapid Type Analysis"},{"location":"call-graph-construction/#variable-type-analysis","text":"Variable Type Analysis (VTA) algorithm further refines the call graph that the RTA constructs. It refines RTA by considering only the assigned instantiations of the implementers of an interface, when resolving a method call on an interface. When considering assignments, we usually need to consider pointer (points-to) relationship. Info VTA algorithm was implemented using the Spark pointer analysis framework. A reimplementation of Spark in SootUp is currently under development. Spark requires an initial call graph to begin with. You can use one of the call graphs that we have constructed above. You can construct a call graph with VTA as follows: SootUp Soot 1 2 3 Spark spark = new Spark . Builder ( view , callGraph ). vta ( true ). build (); spark . analyze (); CallGraph vtaCAllGraph = spark . getCallGraph (); 1 2 3 4 5 6 7 8 9 10 11 12 13 Transform sparkConfig = new Transform ( \"cg.spark\" , null ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"enabled:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"vta:true\" ); PhaseOptions . v (). setPhaseOption ( sparkConfig , \"on-fly-cg:false\" ); Map phaseOptions = PhaseOptions . v (). getPhaseOptions ( sparkConfig ); SparkTransformer . v (). transform ( sparkConfig . getPhaseName (), phaseOptions ); SootMethod src = Scene . v (). getSootClass ( targetTestClassName ). getMethodByName ( \"doStuff\" ); CallGraph cg = Scene . v (). getCallGraph (); Iterator < MethodOrMethodContext > targets = new Targets ( cg . edgesOutOf ( src )); while ( targets . hasNext ()) { SootMethod tgt = ( SootMethod ) targets . next (); System . out . println ( src + \" may call \" + tgt ); }","title":"Variable Type Analysis"},{"location":"docguide/","text":"General MkDocsExtensions Tooltip Hover me Example File inclusion this enables that tutorial code can be tested and will fail if its not up to date anymore :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package sootup.examples.basicSetup; import static org.junit.Assert.assertTrue; import categories.Java8Test; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Collections; import org.junit.Ignore; import org.junit.Test; import org.junit.experimental.categories.Category; import sootup.core.Language; import sootup.core.Project; import sootup.core.inputlocation.AnalysisInputLocation; import sootup.core.jimple.common.expr.JVirtualInvokeExpr; import sootup.core.jimple.common.stmt.JInvokeStmt; import sootup.core.model.SootClass; import sootup.core.model.SootMethod; import sootup.core.signatures.MethodSignature; import sootup.core.types.ClassType; import sootup.core.views.View; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation; import sootup.java.core.JavaProject; import sootup.java.core.JavaSootClass; import sootup.java.core.JavaSootClassSource; import sootup.java.core.language.JavaJimple; import sootup.java.core.language.JavaLanguage; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation; import sootup.jimple.parser.JimpleAnalysisInputLocation; import sootup.jimple.parser.JimpleProject; /** This example illustrates how to create and use a new Soot Project. */ @Category(Java8Test.class) public class BasicSetup { @Test public void createSourceCodeProject() { Path pathToSource = Paths.get(\"src/test/resources/BasicSetup/source\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JavaSourcePathAnalysisInputLocation(pathToSource.toString()); Language language = new JavaLanguage(8); Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); } @Ignore public void createJimpleProject() { Path pathToJimple = Paths.get(\"src/test/resources/BasicSetup/jimple\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JimpleAnalysisInputLocation(pathToJimple); Project project = new JimpleProject(inputLocation); } @Test public void createByteCodeProject() { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\"); AnalysisInputLocation<JavaSootClass> inputLocation = new PathBasedAnalysisInputLocation(pathToBinary, null); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage(8); // Create a new JavaProject based on the input location Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); // Create a signature for the class we want to analyze ClassType classType = project.getIdentifierFactory().getClassType(\"HelloWorld\"); // Create a signature for the method we want to analyze MethodSignature methodSignature = project .getIdentifierFactory() .getMethodSignature( classType, \"main\", \"void\", Collections.singletonList(\"java.lang.String[]\")); // Create a view for project, which allows us to retrieve classes View view = project.createOnDemandView(); // Assert that class is present assertTrue(view.getClass(classType).isPresent()); // Retrieve class SootClass<JavaSootClassSource> sootClass = (SootClass<JavaSootClassSource>) view.getClass(classType).get(); // Retrieve method view.getMethod(methodSignature); // Alternatively: assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent()); SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get(); // Read jimple code of method System.out.println(sootMethod.getBody()); // Assert that Hello world print is present assertTrue( sootMethod.getBody().getStmts().stream() .anyMatch( stmt -> stmt instanceof JInvokeStmt && stmt.getInvokeExpr() instanceof JVirtualInvokeExpr && stmt.getInvokeExpr() .getArg(0) .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\")))); } }","title":"Docguide"},{"location":"docguide/#general","text":"","title":"General"},{"location":"docguide/#mkdocsextensions","text":"","title":"MkDocsExtensions"},{"location":"docguide/#tooltip","text":"Hover me","title":"Tooltip"},{"location":"docguide/#example-file-inclusion","text":"this enables that tutorial code can be tested and will fail if its not up to date anymore :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package sootup.examples.basicSetup; import static org.junit.Assert.assertTrue; import categories.Java8Test; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Collections; import org.junit.Ignore; import org.junit.Test; import org.junit.experimental.categories.Category; import sootup.core.Language; import sootup.core.Project; import sootup.core.inputlocation.AnalysisInputLocation; import sootup.core.jimple.common.expr.JVirtualInvokeExpr; import sootup.core.jimple.common.stmt.JInvokeStmt; import sootup.core.model.SootClass; import sootup.core.model.SootMethod; import sootup.core.signatures.MethodSignature; import sootup.core.types.ClassType; import sootup.core.views.View; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation; import sootup.java.core.JavaProject; import sootup.java.core.JavaSootClass; import sootup.java.core.JavaSootClassSource; import sootup.java.core.language.JavaJimple; import sootup.java.core.language.JavaLanguage; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation; import sootup.jimple.parser.JimpleAnalysisInputLocation; import sootup.jimple.parser.JimpleProject; /** This example illustrates how to create and use a new Soot Project. */ @Category(Java8Test.class) public class BasicSetup { @Test public void createSourceCodeProject() { Path pathToSource = Paths.get(\"src/test/resources/BasicSetup/source\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JavaSourcePathAnalysisInputLocation(pathToSource.toString()); Language language = new JavaLanguage(8); Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); } @Ignore public void createJimpleProject() { Path pathToJimple = Paths.get(\"src/test/resources/BasicSetup/jimple\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JimpleAnalysisInputLocation(pathToJimple); Project project = new JimpleProject(inputLocation); } @Test public void createByteCodeProject() { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\"); AnalysisInputLocation<JavaSootClass> inputLocation = new PathBasedAnalysisInputLocation(pathToBinary, null); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage(8); // Create a new JavaProject based on the input location Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); // Create a signature for the class we want to analyze ClassType classType = project.getIdentifierFactory().getClassType(\"HelloWorld\"); // Create a signature for the method we want to analyze MethodSignature methodSignature = project .getIdentifierFactory() .getMethodSignature( classType, \"main\", \"void\", Collections.singletonList(\"java.lang.String[]\")); // Create a view for project, which allows us to retrieve classes View view = project.createOnDemandView(); // Assert that class is present assertTrue(view.getClass(classType).isPresent()); // Retrieve class SootClass<JavaSootClassSource> sootClass = (SootClass<JavaSootClassSource>) view.getClass(classType).get(); // Retrieve method view.getMethod(methodSignature); // Alternatively: assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent()); SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get(); // Read jimple code of method System.out.println(sootMethod.getBody()); // Assert that Hello world print is present assertTrue( sootMethod.getBody().getStmts().stream() .anyMatch( stmt -> stmt instanceof JInvokeStmt && stmt.getInvokeExpr() instanceof JVirtualInvokeExpr && stmt.getInvokeExpr() .getArg(0) .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\")))); } }","title":"Example File inclusion"},{"location":"getting-started/","text":"Getting Started This page walks you through the core data structures, as well as shows how to get started with SootUp. Core Data Structures Before you get started with the SootUp library, it helps to learn about the following core data structures: Project : defines the outlines of an analysis. SootUp users should first create a Project instance. It is the starting point for all operations. You can define multiple instances of Project at the same time and there are no information shared between them. All caches are always at the project level. Language : represents the programming language of the analyzed code. AnalysisInputLocation : points to the target code to be analyzed. Soot Equivalent It corresponds to the cp option, which specifies the classpath for Soot to find classes to be analyzed. View : presents the code/classes under analysis. Soot Equivalent It corresponds to the Scene class, but it is not a singleton. So it is possible to instantiate multiple views simultaneously. Scope : defines the scope of the View . By default, the View is created with all code found on the AnalysisInputLocation specified for the Project instance. SootClass : represents a class loaded into the View . SootMethod : represents a method of a class. SootField : represents a field of a class. Body : represents a method body in Jimpe. StmtGraph : represents the control flow graph of a method body in Jimple statements. Creating a Project You can use bytecode analysis typically when you do not have access to the source code of the target program. Following example shows how to create project for analyzing Java bytecode. Create a project to analyze Java bytecode 1 2 3 4 5 6 7 8 9 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ). addInputLocation ( inputLocation ). build (); If you have access to the source code, it is also possible to create a project for analyzing source code. Following example shows how to create project for analyzing Java source code. Create a project to analyze Java source code 1 2 3 4 5 6 7 8 9 Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ). addInputLocation ( inputLocation ). build (); If you have a Jimple file, you can create a project for analyzing jimple code directly. Following example shows how to create project for analyzing jimple code. Create a project to analyze jimple code 1 2 3 4 5 6 Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation ); Creating a View It is possible to create different views based on your needs. You can prefer creating a full view, when you are interested in the whole program including all the application code, and the library code; or you can create an on-demand view, when you want to limit your analysis' scope. You can call different view creation methods on the project object. 1 project . createFullView (); Retrieving a Class Each class is identified with a unique signature adhering to Java identifier rules , therefore you first need to specify the class signature ( ClassType ) as shown below. Let's say the following is the target program that we want to analyze: Target Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package example ; public class HelloWorld { public HelloWorld () { } public static void main ( String [] var0 ) { System . out . println ( \"Hello World!\" ); } } Then, we could define the ClassType of the HelloWorld class as follows: Defining a ClassType 1 2 ClassType classType = project . getIdentifierFactory (). getClassType ( \"example.HelloWorld\" ); Once we have a ClassType that identifies the HelloWorld class, we can use it to retrieve the corresponding SootClass object from the view as shown below: Retrieving a SootClass 1 2 SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get (); Retrieving a Method Like the classes, methods also have an identifier which we call MethodSignature . For instance, we can define the method signature for identifying the main method of the HelloWorld class as follows: Defining a MethodSignature 1 2 3 4 5 6 7 8 MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , // method name classType , \"void\" , // return type Collections . singletonList ( \"java.lang.String[]\" )); // args Once we have a MethodSignature that identifies the main method of the HelloWorld class, we can use it to retrieve the corresponding SootMethod object from the view as shown below: Retrieving a SootMethod from the View 1 2 3 4 5 Optional < SootMethod > opt = view . getMethod ( methodSignature ); if ( opt . isPresent ()){ SootMethod method = opt . get (); } Alternatively, we can also retrieve a SootMethod from SootClass that contains it. Retrieving a SootMethod from a SootClass 1 2 3 4 5 Optional <? extends SootMethod > opt = sootClass . getMethod ( methodSignature . getSubSignature ()); if ( opt . isPresent ()){ SootMethod method = opt . get (); } Retrieving the Control-Flow Graph of a Method Each SootMethod contains a Control-Flow Graph (CFG), or as we name here a StmtGraph , that is usually used for program analysis. You can retrieve the CFG of a SootMethod as follows: Retrieving the CFG of a SootMethod 1 sootMethod . getBody (). getStmts (); You can view all the code used until this point below: All the code used above BasicSetup.java SootUp vs Soot Below we show a comparison of the code so far with the same functionality in sootup. SootUp Soot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ) . addInputLocation ( inputLocation ). build (); ClassType classType = project . getIdentifierFactory (). getClassType ( \"HelloWorld\" ); MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , classType , \"void\" , Collections . singletonList ( \"java.lang.String[]\" )); View view = project . createOnDemandView (); SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get (); SootMethod sootMethod = sootClass . getMethod ( methodSignature . getSubSignature ()). get (); sootMethod . getBody (). getStmts (); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 G . reset (); String userdir = System . getProperty ( \"user.dir\" ); String sootCp = userdir + File . separator + \"target\" + File . separator + \"test-classes\" + File . pathSeparator + \"lib\" + File . separator + \"rt.jar\" ; Options . v (). set_soot_classpath ( sootCp ); Options . v (). set_whole_program ( true ); Options . v (). setPhaseOption ( \"cg.cha\" , \"on\" ); Options . v (). setPhaseOption ( \"cg\" , \"all-reachable:true\" ); Options . v (). set_no_bodies_for_excluded ( true ); Options . v (). set_allow_phantom_refs ( true ); Options . v (). setPhaseOption ( \"jb\" , \"use-original-names:true\" ); Options . v (). set_prepend_classpath ( false ); Scene . v (). addBasicClass ( \"java.lang.StringBuilder\" ); SootClass c = Scene . v (). forceResolve ( targetTestClassName , SootClass . BODIES ); if ( c != null ) { c . setApplicationClass (); } Scene . v (). loadNecessaryClasses (); SootMethod method ; for ( SootClass c : Scene . v (). getApplicationClasses ()) { if ( c . getName (). equals ( \"example.HelloWorld\" )){ for ( SootMethod m : c . getMethods ()) { if ( ! m . hasActiveBody ()) { continue ; } if ( m . getName (). equals ( \"entryPoint\" )) { method = m ; break ; } } } } method . getActiveBody (). getUnits ();","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This page walks you through the core data structures, as well as shows how to get started with SootUp.","title":"Getting Started"},{"location":"getting-started/#core-data-structures","text":"Before you get started with the SootUp library, it helps to learn about the following core data structures: Project : defines the outlines of an analysis. SootUp users should first create a Project instance. It is the starting point for all operations. You can define multiple instances of Project at the same time and there are no information shared between them. All caches are always at the project level. Language : represents the programming language of the analyzed code. AnalysisInputLocation : points to the target code to be analyzed. Soot Equivalent It corresponds to the cp option, which specifies the classpath for Soot to find classes to be analyzed. View : presents the code/classes under analysis. Soot Equivalent It corresponds to the Scene class, but it is not a singleton. So it is possible to instantiate multiple views simultaneously. Scope : defines the scope of the View . By default, the View is created with all code found on the AnalysisInputLocation specified for the Project instance. SootClass : represents a class loaded into the View . SootMethod : represents a method of a class. SootField : represents a field of a class. Body : represents a method body in Jimpe. StmtGraph : represents the control flow graph of a method body in Jimple statements.","title":"Core Data Structures"},{"location":"getting-started/#creating-a-project","text":"You can use bytecode analysis typically when you do not have access to the source code of the target program. Following example shows how to create project for analyzing Java bytecode. Create a project to analyze Java bytecode 1 2 3 4 5 6 7 8 9 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ). addInputLocation ( inputLocation ). build (); If you have access to the source code, it is also possible to create a project for analyzing source code. Following example shows how to create project for analyzing Java source code. Create a project to analyze Java source code 1 2 3 4 5 6 7 8 9 Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ). addInputLocation ( inputLocation ). build (); If you have a Jimple file, you can create a project for analyzing jimple code directly. Following example shows how to create project for analyzing jimple code. Create a project to analyze jimple code 1 2 3 4 5 6 Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation );","title":"Creating a Project"},{"location":"getting-started/#creating-a-view","text":"It is possible to create different views based on your needs. You can prefer creating a full view, when you are interested in the whole program including all the application code, and the library code; or you can create an on-demand view, when you want to limit your analysis' scope. You can call different view creation methods on the project object. 1 project . createFullView ();","title":"Creating a View"},{"location":"getting-started/#retrieving-a-class","text":"Each class is identified with a unique signature adhering to Java identifier rules , therefore you first need to specify the class signature ( ClassType ) as shown below. Let's say the following is the target program that we want to analyze: Target Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package example ; public class HelloWorld { public HelloWorld () { } public static void main ( String [] var0 ) { System . out . println ( \"Hello World!\" ); } } Then, we could define the ClassType of the HelloWorld class as follows: Defining a ClassType 1 2 ClassType classType = project . getIdentifierFactory (). getClassType ( \"example.HelloWorld\" ); Once we have a ClassType that identifies the HelloWorld class, we can use it to retrieve the corresponding SootClass object from the view as shown below: Retrieving a SootClass 1 2 SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get ();","title":"Retrieving a Class"},{"location":"getting-started/#retrieving-a-method","text":"Like the classes, methods also have an identifier which we call MethodSignature . For instance, we can define the method signature for identifying the main method of the HelloWorld class as follows: Defining a MethodSignature 1 2 3 4 5 6 7 8 MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , // method name classType , \"void\" , // return type Collections . singletonList ( \"java.lang.String[]\" )); // args Once we have a MethodSignature that identifies the main method of the HelloWorld class, we can use it to retrieve the corresponding SootMethod object from the view as shown below: Retrieving a SootMethod from the View 1 2 3 4 5 Optional < SootMethod > opt = view . getMethod ( methodSignature ); if ( opt . isPresent ()){ SootMethod method = opt . get (); } Alternatively, we can also retrieve a SootMethod from SootClass that contains it. Retrieving a SootMethod from a SootClass 1 2 3 4 5 Optional <? extends SootMethod > opt = sootClass . getMethod ( methodSignature . getSubSignature ()); if ( opt . isPresent ()){ SootMethod method = opt . get (); }","title":"Retrieving a Method"},{"location":"getting-started/#retrieving-the-control-flow-graph-of-a-method","text":"Each SootMethod contains a Control-Flow Graph (CFG), or as we name here a StmtGraph , that is usually used for program analysis. You can retrieve the CFG of a SootMethod as follows: Retrieving the CFG of a SootMethod 1 sootMethod . getBody (). getStmts (); You can view all the code used until this point below: All the code used above BasicSetup.java","title":"Retrieving the Control-Flow Graph of a Method"},{"location":"getting-started/#sootup-vs-soot","text":"Below we show a comparison of the code so far with the same functionality in sootup. SootUp Soot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); JavaLanguage language = new JavaLanguage ( 8 ); Project project = JavaProject . builder ( language ) . addInputLocation ( inputLocation ). build (); ClassType classType = project . getIdentifierFactory (). getClassType ( \"HelloWorld\" ); MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , classType , \"void\" , Collections . singletonList ( \"java.lang.String[]\" )); View view = project . createOnDemandView (); SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get (); SootMethod sootMethod = sootClass . getMethod ( methodSignature . getSubSignature ()). get (); sootMethod . getBody (). getStmts (); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 G . reset (); String userdir = System . getProperty ( \"user.dir\" ); String sootCp = userdir + File . separator + \"target\" + File . separator + \"test-classes\" + File . pathSeparator + \"lib\" + File . separator + \"rt.jar\" ; Options . v (). set_soot_classpath ( sootCp ); Options . v (). set_whole_program ( true ); Options . v (). setPhaseOption ( \"cg.cha\" , \"on\" ); Options . v (). setPhaseOption ( \"cg\" , \"all-reachable:true\" ); Options . v (). set_no_bodies_for_excluded ( true ); Options . v (). set_allow_phantom_refs ( true ); Options . v (). setPhaseOption ( \"jb\" , \"use-original-names:true\" ); Options . v (). set_prepend_classpath ( false ); Scene . v (). addBasicClass ( \"java.lang.StringBuilder\" ); SootClass c = Scene . v (). forceResolve ( targetTestClassName , SootClass . BODIES ); if ( c != null ) { c . setApplicationClass (); } Scene . v (). loadNecessaryClasses (); SootMethod method ; for ( SootClass c : Scene . v (). getApplicationClasses ()) { if ( c . getName (). equals ( \"example.HelloWorld\" )){ for ( SootMethod m : c . getMethods ()) { if ( ! m . hasActiveBody ()) { continue ; } if ( m . getName (). equals ( \"entryPoint\" )) { method = m ; break ; } } } } method . getActiveBody (). getUnits ();","title":"SootUp vs Soot"},{"location":"installation/","text":"Installation Building from Source Build from source if you'd like to get the most recent changes. You can download the project as a zip file, or clone it using your favorite git client app or the command line: 1 git clone https://github.com/secure-software-engineering/SootUp.git SootUp is a maven project. You can import it into your favorite IDE as a maven project. Run maven clean and install tasks using your IDE's maven plugin to set up the project. Alternatively, you can execute the following command in the project directory: 1 mvn install Or if you want to skip unit tests while building: 1 mvn -Dskiptests install Using the release Alternatively you can directly get the release versions. SootUp is available in maven central, you can include it in your project as follows. Below we only show how you can add the SootUp modules to your project. It is not necessary to add all the modules as dependency. Depending on your needs you can import only the modules you need. See Modules to learn more about which modules you might need. 1. Maven Add the following dependency in the pom.xml file of your project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 <dependencies> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.sourcecode</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.bytecode</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.jimple.parser</artifactId> <version>1.0.0</version> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.callgraph</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.analysis</artifactId> <version>1.0.0</version> </dependency> </dependencies> 2. Gradle Add the following dependency in the build.gradle file of your project. 1 2 3 4 5 6 7 compile \"org.soot-oss:sootup.core:1.0.0\" compile \"org.soot-oss:sootup.java.core:1.0.0\" compile \"org.soot-oss:sootup.java.sourcecode:1.0.0\" compile \"org.soot-oss:sootup.java.bytecode:1.0.0\" compile \"org.soot-oss:sootup.jimple.parser:1.0.0\" compile \"org.soot-oss:sootup.callgraph:1.0.0\" compile \"org.soot-oss:sootup.analysis:1.0.0\"","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#building-from-source","text":"Build from source if you'd like to get the most recent changes. You can download the project as a zip file, or clone it using your favorite git client app or the command line: 1 git clone https://github.com/secure-software-engineering/SootUp.git SootUp is a maven project. You can import it into your favorite IDE as a maven project. Run maven clean and install tasks using your IDE's maven plugin to set up the project. Alternatively, you can execute the following command in the project directory: 1 mvn install Or if you want to skip unit tests while building: 1 mvn -Dskiptests install","title":"Building from Source"},{"location":"installation/#using-the-release","text":"Alternatively you can directly get the release versions. SootUp is available in maven central, you can include it in your project as follows. Below we only show how you can add the SootUp modules to your project. It is not necessary to add all the modules as dependency. Depending on your needs you can import only the modules you need. See Modules to learn more about which modules you might need.","title":"Using the release"},{"location":"installation/#1-maven","text":"Add the following dependency in the pom.xml file of your project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 <dependencies> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.sourcecode</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.java.bytecode</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.jimple.parser</artifactId> <version>1.0.0</version> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.callgraph</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>org.soot-oss</groupId> <artifactId>sootup.analysis</artifactId> <version>1.0.0</version> </dependency> </dependencies>","title":"1. Maven"},{"location":"installation/#2-gradle","text":"Add the following dependency in the build.gradle file of your project. 1 2 3 4 5 6 7 compile \"org.soot-oss:sootup.core:1.0.0\" compile \"org.soot-oss:sootup.java.core:1.0.0\" compile \"org.soot-oss:sootup.java.sourcecode:1.0.0\" compile \"org.soot-oss:sootup.java.bytecode:1.0.0\" compile \"org.soot-oss:sootup.jimple.parser:1.0.0\" compile \"org.soot-oss:sootup.callgraph:1.0.0\" compile \"org.soot-oss:sootup.analysis:1.0.0\"","title":"2. Gradle"},{"location":"jimple/","text":"Jimple What is Jimple? Jimple is the intermediate representation IR of Soot, and thus SootUp. Soot's intention is to provide a simplified way to analyze JVM bytecode. JVM bytecode is stack-based, which makes it difficult for program analysis. Java source code, on the other hand, is also not quite suitable for program analysis, due to its nested structures. Therefore, Jimple aims to bring the best of both worlds, a non-stack-based and flat (non-nested) representation. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable. Info To learn more about jimple, refer to the thesis by Raja Vallee-Rai. It might help to visualize how the Jimple version of a Java code looks like. Have a look at the following example on the HelloWorld class. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class HelloWorld extends java.lang.Object { public void <init> () { HelloWorld r0 ; r0 := @this: HelloWorld ; specialinvoke r0 .< java.lang.Object : void <init> ()>(); return ; } public static void main ( java.lang.String []) { java.lang.String[] r0 ; java.io.PrintStream $r1 ; r0 := @parameter0 : java.lang.String []; $r1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $r1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Hello world!\" ); return ; } } 1 2 3 4 5 6 7 8 9 10 11 public class HelloWorld { public HelloWorld () { } public static void main ( String [] var0 ) { System . out . println ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // class version 52.0 (52) // access flags 0x21 public class analysis/HelloWorld { // compiled from: HelloWorld.java // access flags 0x1 public <init>()V L0 LINENUMBER 4 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 6 L1 RETURN L2 LOCALVARIABLE this Lanalysis/HelloWorld; L0 L2 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 9 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Hello World!\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 10 L1 RETURN L2 LOCALVARIABLE var0 [Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } Jimple Grammar Structure Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.) Class (or Interface) A class consists of Fields and Methods. It is referenced by its ClassType. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } } 1 2 3 package target.exercise1 ; public class DemoClass {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 } Field A Field is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : double pi > = 3.14 ; return ; } } /* \"this.<target.exercise1.DemoClass: double pi>\" is JInstanceFieldRef */ 1 2 3 4 5 package target.exercise1 ; public class DemoClass { private final double pi = 3.14 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x12 private final D pi = 3.14 // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 LDC 3.14 PUTFIELD target/exercise1/DemoClass.pi : D RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 } Method and the Body The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature and contains a StmtGraph that models the sequence of single instructions/statements (Stmts). Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); virtualinvoke this .< target.exercise1.DemoClass : void demoMethod ()>(); return ; } public void demoMethod () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Inside method.\" ); return ; } } /* \"<target.exercise1.DemoClass: void demoMethod()>\" and \"<target.exercise1.DemoClass: void <init>()>\" are instances of SootMethod */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { DemoClass (){ demoMethod (); } public void demoMethod (){ System . out . println ( \"Inside method.\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x0 <init>()V L0 LINENUMBER 5 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 6 L1 ALOAD 0 INVOKEVIRTUAL target/exercise1/DemoClass.demoMethod ()V L2 LINENUMBER 7 L2 RETURN L3 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L3 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public demoMethod()V L0 LINENUMBER 10 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Inside method.\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 11 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } Signatures Signatures are required for identifying or referencing things across a method, such as Classes, Interfaces, Methods or Fields. Locals, on the other hand, do not need signatures, since they are referenced within method boundaries. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : double pi > = 3.14 ; return ; } public void demoMethod () { java.io.PrintStream $stack3 , $stack5 ; java.lang.StringBuilder $stack4 , $stack6 , $stack7 ; java.lang.String $stack8 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"pi : 3.14\" ); $stack5 = < java.lang.System : java.io.PrintStream out >; $stack4 = new java.lang.StringBuilder ; specialinvoke $stack4 .< java.lang.StringBuilder : void <init> ()>(); $stack6 = virtualinvoke $stack4 .< java.lang.StringBuilder : java.lang.StringBuilder append ( java.lang.String )> ( \"pi : \" ); $stack7 = virtualinvoke $stack6 .< java.lang.StringBuilder : java.lang.StringBuilder append ( double )>( 3.1415 ); $stack8 = virtualinvoke $stack7 .< java.lang.StringBuilder : java.lang.String toString ()>(); virtualinvoke $stack5 .< java.io.PrintStream : void println ( java.lang.String )>( $stack8 ); return ; } } /* For JInstanceFieldRef \"this.<target.exercise1.DemoClass: double pi>\" signature is <target.exercise1.DemoClass: double pi> Similarly, we have other signatures like <java.lang.Object: void <init>()>, <java.io.PrintStream: void println(java.lang.String)> and so on. */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { private final double pi = 3.14 ; public void demoMethod (){ double localPi = 3.1415 ; System . out . println ( \"pi : \" + pi ); System . out . println ( \"pi : \" + localPi ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x12 private final D pi = 3.14 // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 LDC 3.14 PUTFIELD target/exercise1/DemoClass.pi : D RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 // access flags 0x1 public demoMethod()V L0 LINENUMBER 6 L0 LDC 3.1415 DSTORE 1 L1 LINENUMBER 7 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"pi : 3.14\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L2 LINENUMBER 8 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.<init> ()V LDC \"pi : \" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;) Ljava/lang/StringBuilder; DLOAD 1 INVOKEVIRTUAL java/lang/StringBuilder.append (D)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 9 L3 RETURN L4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0 LOCALVARIABLE localPi D L1 L4 1 MAXSTACK = 4 MAXLOCALS = 3 } Trap A Trap is a mechanism to model exceptional flow. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void divideExample ( int , int ) { int x , y , $stack4 ; java.io.PrintStream $stack5 , $stack7 ; java.lang.Exception $stack6 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; y := @parameter1 : int ; label1: $stack5 = < java.lang.System : java.io.PrintStream out >; $stack4 = x / y ; virtualinvoke $stack5 .< java.io.PrintStream : void println ( int )>( $stack4 ); label2: goto label4; label3: $stack6 := @caughtexception ; $stack7 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack7 .< java.io.PrintStream : void println ( java.lang.String )>( \"Exception caught\" ); label4: return ; catch java.lang.Exception from label1 to label2 with label3; } } /* By calling getTraps() method, we can get the Traip chain. For the above jimple code, we have the below trap: Trap : begin : $stack5 = <java.lang.System: java.io.PrintStream out> end : goto [?= return] handler: $stack6 := @caughtexception */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { public void divideExample ( int x , int y ){ try { System . out . println ( x / y ); } catch ( Exception e ){ System . out . println ( \"Exception caught\" ); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public divideExample(II)V TRYCATCHBLOCK L0 L1 L2 java/lang/Exception L0 LINENUMBER 6 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 ILOAD 2 IDIV INVOKEVIRTUAL java/io/PrintStream.println (I)V L1 LINENUMBER 9 L1 GOTO L3 L2 LINENUMBER 7 L2 FRAME SAME1 java/lang/Exception ASTORE 3 L4 LINENUMBER 8 L4 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Exception caught\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 10 L3 FRAME SAME RETURN L5 LOCALVARIABLE e Ljava/lang/Exception; L4 L3 3 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE x I L0 L5 1 LOCALVARIABLE y I L0 L5 2 MAXSTACK = 3 MAXLOCALS = 4 } Stmt The main piece of Jimple is a Statement (Stmt). Stmts represent that can be executed by the JVM. Branching Statements A BranchingStmt's job is to model the flow between Stmts. JGotoStmt for unconditional flow. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public static void sampleMethod () { int i ; i = 0 ; label1: if i >= 5 goto label3; if i != 3 goto label2; goto label3; label2: i = i + 1 ; goto label1; label3: return ; } } /* Here for statements \"goto label3;\" and \"goto label1;\", we have two instances of JGotoStmt : \"goto[?=return]\" and \"goto[?=(branch)]\". */ 1 2 3 4 5 6 7 8 9 10 11 12 package target.exercise1 ; public class DemoClass { public static void sampleMethod (){ label1 : for ( int i = 0 ; i < 5 ; i ++ ){ if ( i == 3 ){ break label1 ; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static sampleMethod()V L0 LINENUMBER 6 L0 ICONST_0 ISTORE 0 L1 FRAME APPEND [I] ILOAD 0 ICONST_5 IF_ICMPGE L2 L3 LINENUMBER 7 L3 ILOAD 0 ICONST_3 IF_ICMPNE L4 L5 LINENUMBER 8 L5 GOTO L2 L4 LINENUMBER 6 L4 FRAME SAME IINC 0 1 GOTO L1 L2 LINENUMBER 11 L2 FRAME CHOP 1 RETURN LOCALVARIABLE i I L1 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } JIfStmt for conditional flow depending on boolean Expression (AbstractConditionExpr) so they have two successor Stmt's. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public static void sampleMethod ( int ) { int x , $stack1 ; java.io.PrintStream $stack2 , $stack3 ; x := @parameter0 : int ; $stack1 = x % 2 ; if $stack1 != 0 goto label1; $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"Even\" ); goto label2; label1: $stack2 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack2 .< java.io.PrintStream : void println ( java.lang.String )>( \"Odd\" ); label2: return ; } } /* For statement \"if $stack1 != 0 goto label1;\", we have an instance of JIfStmt : \"if $stack1 != 0 goto $stack2 = <java.lang.System:java.io.PrintStream out>\". */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { public static void sampleMethod ( int x ){ if ( x % 2 == 0 ){ System . out . println ( \"Even\" ); } else { System . out . println ( \"Odd\" ); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static sampleMethod(I)V L0 LINENUMBER 5 L0 ILOAD 0 ICONST_2 IREM IFNE L1 L2 LINENUMBER 6 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Even\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V GOTO L3 L1 LINENUMBER 8 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Odd\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 10 L3 FRAME SAME RETURN L4 LOCALVARIABLE x I L0 L4 0 MAXSTACK = 2 MAXLOCALS = 1 } JSwitchStmt for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. All other Stmts are not manipulating the flow, which means they have a single successor Stmt as long as they are not exiting the flow inside a method. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void switchExample ( int ) { int x ; java.io.PrintStream $stack2 , $stack3 , $stack4 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; lookupswitch ( x ) { case 1: goto label1; case 2: goto label2; default : goto label3; }; label1: $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input 1\" ); goto label4; label2: $stack2 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack2 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input 2\" ); goto label4; label3: $stack4 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack4 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input more than 2\" ); label4: return ; } } /* Here for below statement: lookupswitch(x) { case 1: goto label1; case 2: goto label2; default: goto label3; }; we have an instance of JLookupSwitchStmt : lookupswitch(x) { case 1: goto $stack3 = <java.lang.System: java.io.PrintStream out>; case 2: goto $stack2 = <java.lang.System: java.io.PrintStream out>; default: goto $stack4 = <java.lang.System: java.io.PrintStream out>; } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package target.exercise1 ; public class DemoClass { public void switchExample ( int x ){ switch ( x ){ case 1 : System . out . println ( \"Input 1\" ); break ; case 2 : System . out . println ( \"Input 2\" ); break ; default : System . out . println ( \"Input more than 2\" ); break ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public switchExample(I)V L0 LINENUMBER 5 L0 ILOAD 1 LOOKUPSWITCH 1: L1 2: L2 default: L3 L1 LINENUMBER 7 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input 1\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L4 LINENUMBER 8 L4 GOTO L5 L2 LINENUMBER 11 L2 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input 2\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L6 LINENUMBER 12 L6 GOTO L5 L3 LINENUMBER 15 L3 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input more than 2\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L5 LINENUMBER 19 L5 FRAME SAME RETURN L7 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L7 0 LOCALVARIABLE x I L0 L7 1 MAXSTACK = 2 MAXLOCALS = 2 } JReturnStmt & JReturnVoidStmt They end the execution/flow inside the current method and return (a value) to its caller. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public int increment ( int ) { int x , $stack2 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; $stack2 = x + 1 ; return $stack2 ; } public void print () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Inside method print\" ); return ; } } /* \"return $stack2\" is JReturnStmt. \"return\" is JReturnVoidStmt. */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { public int increment ( int x ){ return x + 1 ; } public void print (){ System . out . println ( \"Inside method print\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public increment(I)I L0 LINENUMBER 5 L0 ILOAD 1 ICONST_1 IADD IRETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE x I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x1 public print()V L0 LINENUMBER 8 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Inside method print\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 9 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } JThrowStmt Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void divideExample ( int , int ) { int y , x , $stack6 ; java.lang.StringBuilder $stack3 , $stack5 , $stack7 ; java.io.PrintStream $stack4 ; java.lang.String $stack8 ; java.lang.RuntimeException $stack9 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; y := @parameter1 : int ; if y != 0 goto label1; $stack9 = new java.lang.RuntimeException ; specialinvoke $stack9 .< java.lang.RuntimeException : void <init> ( java.lang.String )>( \"Divide by zero error\" ); throw $stack9 ; label1: $stack4 = < java.lang.System : java.io.PrintStream out >; $stack3 = new java.lang.StringBuilder ; specialinvoke $stack3 .< java.lang.StringBuilder : void <init> ()>(); $stack5 = virtualinvoke $stack3 .< java.lang.StringBuilder : java.lang.StringBuilder append ( java.lang.String )>( \"Divide result : \" ); $stack6 = x / y ; $stack7 = virtualinvoke $stack5 .< java.lang.StringBuilder : java.lang.StringBuilder append ( int )>( $stack6 ); $stack8 = virtualinvoke $stack7 .< java.lang.StringBuilder : java.lang.String toString ()>(); virtualinvoke $stack4 .< java.io.PrintStream : void println ( java.lang.String )>( $stack8 ); return ; } } /* \"throw $stack9\" is JThrowStmt. */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { public void divideExample ( int x , int y ){ if ( y == 0 ){ throw new RuntimeException ( \"Divide by zero error\" ); } System . out . println ( \"Divide result : \" + x / y ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public divideExample(II)V L0 LINENUMBER 5 L0 ILOAD 2 IFNE L1 L2 LINENUMBER 6 L2 NEW java/lang/RuntimeException DUP LDC \"Divide by zero error\" INVOKESPECIAL java/lang/RuntimeException.<init> (Ljava/lang/String;)V ATHROW L1 LINENUMBER 8 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.<init> ()V LDC \"Divide result : \" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ILOAD 1 ILOAD 2 IDIV INVOKEVIRTUAL java/lang/StringBuilder.append (I)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 9 L3 RETURN L4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0 LOCALVARIABLE x I L0 L4 1 LOCALVARIABLE y I L0 L4 2 MAXSTACK = 4 MAXLOCALS = 3 } JInvokeStmt transfers the control flow to another method until the called method returns. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void print ( int ) { target.exercise1.DemoClass this ; int x , a ; java.io.PrintStream $stack4 , $stack6 ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; a = virtualinvoke this .< target.exercise1.DemoClass : int increment ( int )>( x ); $stack4 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack4 .< java.io.PrintStream : void println ( int )>( a ); a = virtualinvoke this .< target.exercise1.DemoClass : int increment ( int )>( a ); $stack6 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack6 .< java.io.PrintStream : void println ( int )>( a ); return ; } public int increment ( int ) { int x , $stack2 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; $stack2 = x + 1 ; return $stack2 ; } } /* \"specialinvoke this.<java.lang.Object: void <init>()>()\", \"virtualinvoke this.<target.exercise1.DemoClass: int increment(int)>(x)\", \"virtualinvoke this.<target.exercise1.DemoClass: int increment(int)>(a)\" are JInvokeStmts. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 package target.exercise1 ; public class DemoClass { public void print ( int x ){ int a = increment ( x ); System . out . println ( a ); a = increment ( a ); System . out . println ( a ); } public int increment ( int x ){ return x + 1 ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public print(I)V L0 LINENUMBER 5 L0 ALOAD 0 ILOAD 1 INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I ISTORE 2 L1 LINENUMBER 6 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (I)V L2 LINENUMBER 7 L2 ALOAD 0 ILOAD 2 INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I ISTORE 2 L3 LINENUMBER 8 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (I)V L4 LINENUMBER 9 L4 RETURN L5 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE x I L0 L5 1 LOCALVARIABLE a I L1 L5 2 MAXSTACK = 2 MAXLOCALS = 3 // access flags 0x1 public increment(I)I L0 LINENUMBER 11 L0 ILOAD 1 ICONST_1 IADD IRETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE x I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 } JAssignStmt assigns a Value from the right hand-side to the left hand-side. Left hand-side of an assignment can be a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. Right hand-side of an assignment can be an expression (Expr), a Local, a FieldRef or a Constant. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : int counter > = 0 ; return ; } public int updateCounter () { target.exercise1.DemoClass this ; int $stack1 , $stack2 , $stack3 ; this := @this: target.exercise1.DemoClass ; $stack1 = this .< target.exercise1.DemoClass : int counter >; $stack2 = $stack1 + 1 ; this .< target.exercise1.DemoClass : int counter > = $stack2 ; $stack3 = this .< target.exercise1.DemoClass : int counter >; return $stack3 ; } } /* \"this.<target.exercise1.DemoClass: int counter> = 0\", \"$stack1 = this.<target.exercise1.DemoClass: int counter>\", \"$stack2 = $stack1 + 1\" \"this.<target.exercise1.DemoClass: int counter> = $stack2\" \"$stack3 = this.<target.exercise1.DemoClass: int counter>\" are JAssignStmts. */ 1 2 3 4 5 6 7 8 9 package target.exercise1 ; public class DemoClass { private int counter = 0 ; public int updateCounter (){ counter = counter + 1 ; return counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 ICONST_0 PUTFIELD target/exercise1/DemoClass.counter : I RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public updateCounter()I L0 LINENUMBER 6 L0 ALOAD 0 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I ICONST_1 IADD PUTFIELD target/exercise1/DemoClass.counter : I L1 LINENUMBER 7 L1 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I IRETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 } JIdentityStmt is semantically like the JAssignStmt and handles assignments of IdentityRef's to make implicit assignments explicit into the StmtGraph. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void DemoClass ( int ) { target.exercise1.DemoClass this ; int counter ; this := @this: target.exercise1.DemoClass ; counter := @parameter0 : int ; this .< target.exercise1.DemoClass : int counter > = counter ; return ; } } /* \"this := @this: target.exercise1.DemoClass\" and \"counter := @parameter0: int\" are JIdentityStmts */ 1 2 3 4 5 6 7 8 package target.exercise1 ; public class DemoClass { private int counter ; public void DemoClass ( int counter ){ this . counter = counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public DemoClass(I)V L0 LINENUMBER 6 L0 ALOAD 0 ILOAD 1 PUTFIELD target/exercise1/DemoClass.counter : I L1 LINENUMBER 7 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 LOCALVARIABLE counter I L0 L2 1 MAXSTACK = 2 MAXLOCALS = 2 } JEnterMonitorStmt & JExitMonitorStmt marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : int counter > = 0 ; return ; } public int updateCounter () { target.exercise1.DemoClass this ; int $stack4 , $stack5 , $stack7 ; java.lang.Throwable $stack8 ; this := @this: target.exercise1.DemoClass ; entermonitor this ; label1: $stack4 = this .< target.exercise1.DemoClass : int counter >; $stack5 = $stack4 + 1 ; this .< target.exercise1.DemoClass : int counter > = $stack5 ; exitmonitor this ; label2: goto label5; label3: $stack8 := @caughtexception ; exitmonitor this ; label4: throw $stack8 ; label5: $stack7 = this .< target.exercise1.DemoClass : int counter >; return $stack7 ; catch java.lang.Throwable from label1 to label2 with label3; catch java.lang.Throwable from label3 to label4 with label3; } } /* \"entermonitor this\" is JEnterMonitorStmt. \"exitmonitor this\" is JExitMonitorStmt. */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { private int counter = 0 ; public int updateCounter (){ synchronized ( this ) { counter = counter + 1 ; } return counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 ICONST_0 PUTFIELD target/exercise1/DemoClass.counter : I RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public updateCounter()I TRYCATCHBLOCK L0 L1 L2 null TRYCATCHBLOCK L2 L3 L2 null L4 LINENUMBER 6 L4 ALOAD 0 DUP ASTORE 1 MONITORENTER L0 LINENUMBER 7 L0 ALOAD 0 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I ICONST_1 IADD PUTFIELD target/exercise1/DemoClass.counter : I L5 LINENUMBER 8 L5 ALOAD 1 MONITOREXIT L1 GOTO L6 L2 FRAME FULL [target/exercise1/DemoClass java/lang/Object] [java/lang/Throwable] ASTORE 2 ALOAD 1 MONITOREXIT L3 ALOAD 2 ATHROW L6 LINENUMBER 9 L6 FRAME CHOP 1 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I IRETURN L7 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L4 L7 0 MAXSTACK = 3 MAXLOCALS = 3 } JRetStmt JBreakpointStmt models a Breakpoint set by a Debugger (usually not relevant for static analyses) Immediate An Immediate has a given Type and consists of a Local (\"a Variable\", \"Something that contains a Value\") or a Constant (\"Something that is a Value\"). Type VoidType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void voidMethod () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"In voidMethod().\" ); return ; } } /* For the SootMethod - <target.exercise1.DemoClass: void voidMethod()>, returnType is instance of VoidType. */ 1 2 3 4 5 6 7 package target.exercise1 ; public class DemoClass { public void voidMethod (){ System . out . println ( \"In voidMethod().\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public voidMethod()V L0 LINENUMBER 5 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"In voidMethod().\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 6 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } PrimaryType BooleanType, ByteType, CharType, ShortType, IntType, LongType, DoubleType, FloatType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void display () { java.io.PrintStream $stack11 , $stack13 , $stack15 , $stack17 , $stack19 , $stack21 , $stack23 , $stack25 ; int $stack12 , $stack14 , $stack16 , $stack18 ; long $stack20 ; double $stack22 ; float $stack24 ; target.exercise1.DemoClass this ; boolean $stack26 ; this := @this: target.exercise1.DemoClass ; $stack11 = < java.lang.System : java.io.PrintStream out >; goto label1; label1: $stack26 = 0 ; virtualinvoke $stack11 .< java.io.PrintStream : void println ( boolean )>( $stack26 ); $stack13 = < java.lang.System : java.io.PrintStream out >; $stack12 = 127 - 1 ; virtualinvoke $stack13 .< java.io.PrintStream : void println ( int )>( $stack12 ); $stack15 = < java.lang.System : java.io.PrintStream out >; $stack14 = 97 + 1 ; virtualinvoke $stack15 .< java.io.PrintStream : void println ( int )>( $stack14 ); $stack17 = < java.lang.System : java.io.PrintStream out >; $stack16 = 1123 + 1 ; virtualinvoke $stack17 .< java.io.PrintStream : void println ( int )>( $stack16 ); $stack19 = < java.lang.System : java.io.PrintStream out >; $stack18 = 123456 + 1 ; virtualinvoke $stack19 .< java.io.PrintStream : void println ( int )>( $stack18 ); $stack21 = < java.lang.System : java.io.PrintStream out >; $stack20 = 10L + 1L ; virtualinvoke $stack21 .< java.io.PrintStream : void println ( long )>( $stack20 ); $stack23 = < java.lang.System : java.io.PrintStream out >; $stack22 = 10.1 + 1.0 ; virtualinvoke $stack23 .< java.io.PrintStream : void println ( double )>( $stack22 ); $stack25 = < java.lang.System : java.io.PrintStream out >; $stack24 = 10.1F + 1.0F ; virtualinvoke $stack25 .< java.io.PrintStream : void println ( float )>( $stack24 ); return ; } } /* The JimpleLocal $stack12, $stack14, $stack16, $stack18 are of IntType. Similarly, $stack20 is of LongType, $stack22 is of DoubleType and so on. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package target.exercise1 ; public class DemoClass { public void display (){ boolean varBoolean = true ; byte varByte = 127 ; char varChar = 'a' ; short varShort = 1123 ; int varInt = 123456 ; long varLong = 10L ; double varDouble = 10.10 ; float varFloat = 10.10f ; System . out . println ( ! varBoolean ); System . out . println ( varByte - 1 ); System . out . println ( varChar + 1 ); System . out . println ( varShort + 1 ); System . out . println ( varInt + 1 ); System . out . println ( varLong + 1 ); System . out . println ( varDouble + 1 ); System . out . println ( varFloat + 1 ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public display()V L0 LINENUMBER 5 L0 ICONST_1 ISTORE 1 L1 LINENUMBER 6 L1 BIPUSH 127 ISTORE 2 L2 LINENUMBER 7 L2 BIPUSH 97 ISTORE 3 L3 LINENUMBER 8 L3 SIPUSH 1123 ISTORE 4 L4 LINENUMBER 9 L4 LDC 123456 ISTORE 5 L5 LINENUMBER 10 L5 LDC 10 LSTORE 6 L6 LINENUMBER 11 L6 LDC 10.1 DSTORE 8 L7 LINENUMBER 12 L7 LDC 10.1 FSTORE 10 L8 LINENUMBER 14 L8 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 IFNE L9 ICONST_1 GOTO L10 L9 FRAME FULL [target/exercise1/DemoClass I I I I I J D F] [java/io/PrintStream] ICONST_0 L10 FRAME FULL [target/exercise1/DemoClass I I I I I J D F] [java/io/PrintStream I] INVOKEVIRTUAL java/io/PrintStream.println (Z)V L11 LINENUMBER 15 L11 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 ICONST_1 ISUB INVOKEVIRTUAL java/io/PrintStream.println (I)V L12 LINENUMBER 16 L12 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 3 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L13 LINENUMBER 17 L13 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 4 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L14 LINENUMBER 18 L14 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 5 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L15 LINENUMBER 19 L15 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LLOAD 6 LCONST_1 LADD INVOKEVIRTUAL java/io/PrintStream.println (J)V L16 LINENUMBER 20 L16 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; DLOAD 8 DCONST_1 DADD INVOKEVIRTUAL java/io/PrintStream.println (D)V L17 LINENUMBER 21 L17 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; FLOAD 10 FCONST_1 FADD INVOKEVIRTUAL java/io/PrintStream.println (F)V L18 LINENUMBER 23 L18 RETURN L19 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L19 0 LOCALVARIABLE varBoolean Z L1 L19 1 LOCALVARIABLE varByte B L2 L19 2 LOCALVARIABLE varChar C L3 L19 3 LOCALVARIABLE varShort S L4 L19 4 LOCALVARIABLE varInt I L5 L19 5 LOCALVARIABLE varLong J L6 L19 6 LOCALVARIABLE varDouble D L7 L19 8 LOCALVARIABLE varFloat F L8 L19 10 MAXSTACK = 5 MAXLOCALS = 11 } ReferenceType ClassType, ArrayType NullType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public target.exercise1.DemoClass getObject ( target.exercise1.DemoClass ) { target.exercise1.DemoClass obj , this ; this := @this: target.exercise1.DemoClass ; obj := @parameter0 : target.exercise1.DemoClass ; return obj ; } public void compute ( boolean ) { int[] b ; java.io.PrintStream $stack5 , $stack6 ; boolean check ; target.exercise1.DemoClass this ; int i ; null_type $r0 ; java.lang.NullPointerException soot0 ; this := @this: target.exercise1.DemoClass ; check := @parameter0 : boolean ; b = newarray ( int )[5]; i = 0 ; label1: if i >= 5 goto label3; if check == 0 goto label2; $r0 = ( null_type ) i ; soot0 = new java.lang.NullPointerException ; specialinvoke soot0 .< java.lang.NullPointerException : void <init> ( java.lang.String )> ( \"This statement would have triggered an Exception: a[i#1] = $r0\" ); throw soot0 ; label2: b [ i ] = i ; i = i + 1 ; goto label1; label3: $stack5 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack5 .< java.io.PrintStream : void println ( java.lang.Object )>( b ); $stack6 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack6 .< java.io.PrintStream : void println ( java.lang.Object )>( null ); return ; } } /* The JimpleLocal b is of ArrayType, and JimpleLocal $r0 is of NullType. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package target.exercise1 ; public class DemoClass { public DemoClass getObject ( DemoClass obj ){ return obj ; } public void compute ( boolean check ){ int a [] = null ; int b [] = new int [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( check ){ a [ i ] = i ; } b [ i ] = i ; } System . out . println ( b ); System . out . println ( a ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public getObject(Ltarget/exercise1/DemoClass;)Ltarget/exercise1/DemoClass; L0 LINENUMBER 6 L0 ALOAD 1 ARETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE obj Ltarget/exercise1/DemoClass; L0 L1 1 MAXSTACK = 1 MAXLOCALS = 2 // access flags 0x1 public compute(Z)V L0 LINENUMBER 10 L0 ACONST_NULL ASTORE 2 L1 LINENUMBER 11 L1 ICONST_5 NEWARRAY T_INT ASTORE 3 L2 LINENUMBER 12 L2 ICONST_0 ISTORE 4 L3 FRAME APPEND [[I [I I] ILOAD 4 ICONST_5 IF_ICMPGE L4 L5 LINENUMBER 13 L5 ILOAD 1 IFEQ L6 L7 LINENUMBER 14 L7 ALOAD 2 ILOAD 4 ILOAD 4 IASTORE L6 LINENUMBER 16 L6 FRAME SAME ALOAD 3 ILOAD 4 ILOAD 4 IASTORE L8 LINENUMBER 12 L8 IINC 4 1 GOTO L3 L4 LINENUMBER 18 L4 FRAME CHOP 1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 3 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L9 LINENUMBER 19 L9 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L10 LINENUMBER 20 L10 RETURN L11 LOCALVARIABLE i I L3 L4 4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L11 0 LOCALVARIABLE check Z L0 L11 1 LOCALVARIABLE a [I L1 L11 2 LOCALVARIABLE b [I L2 L11 3 MAXSTACK = 3 MAXLOCALS = 5 } Local jimple $i0 A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt. Jimple Java Byte Code ```jimple public class target.exercise1.DemoClass extends java.lang.Object { public void () { target.exercise1.DemoClass this; this := @this: target.exercise1.DemoClass; specialinvoke this. ()>(); return; } public void compute() { java.io.PrintStream $stack2, $stack3; target.exercise1.DemoClass this; int local#2; 1 2 3 4 5 6 7 8 this := @this: target.exercise1.DemoClass; $stack2 = <java.lang.System: java.io.PrintStream out>; virtualinvoke $stack2.<java.io.PrintStream: void println(int)>(1); local#2 = this.<target.exercise1.DemoClass: int global>; $stack3 = <java.lang.System: java.io.PrintStream out>; virtualinvoke $stack3.<java.io.PrintStream: void println(int)>(local#2); return; } } /* $stack2, this, $stack3, local#2 are all JimpleLocal. \"this := @this: target.exercise1.DemoClass\" is JIdentityStmt \"$stack2 = \", \"local#2 = this. \", \"$stack3 = \" are JAssignStmt */ ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package target.exercise1 ; public class DemoClass { private int global ; public void compute (){ int local ; local = 1 ; System . out . println ( local ); local = this . global ; System . out . println ( local ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I global // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public compute()V L0 LINENUMBER 9 L0 ICONST_1 ISTORE 1 L1 LINENUMBER 10 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (I)V L2 LINENUMBER 11 L2 ALOAD 0 GETFIELD target/exercise1/DemoClass.global : I ISTORE 1 L3 LINENUMBER 12 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (I)V L4 LINENUMBER 14 L4 RETURN L5 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE local I L1 L5 1 MAXSTACK = 2 MAXLOCALS = 2 } Constant represents a value itself. don't confuse it with a variable/Local which has a immutable (i.e. final) attribute. There exists a constant entity for every Type - that way all value types can have a representation. Expr An expression is a language construct that returns a value. E.g. a binary operation such as addition. Ref JArrayRef jimple $arr[1] referencing a position inside an array. JFieldRef (JStaticFieldRef & JInstanceFieldRef) jimple <SomePackage.ExampleClass: fieldname> // or $r1.<SomePackage.ExampleClass: fieldname> referencing a Field via its FieldSignature and if necessary (i.e. with JInstanceFieldRef) the corresponding Local instance that points to the object instance. IdentityRef The IdentityRef makes those implicit special value assignments explicit. JThisRef jimple @this: package.fruit.Banana represents the this pointer of the current class. JCaughtExceptionRef jimple @caughtexception represents the value of the thrown exception (caught by this exceptionhandler). JParameterRef jimple $i0 := @parameter0 $i1 := @parameter1 represents a parameter of a method, identified by its index.","title":"Jimple"},{"location":"jimple/#jimple","text":"What is Jimple? Jimple is the intermediate representation IR of Soot, and thus SootUp. Soot's intention is to provide a simplified way to analyze JVM bytecode. JVM bytecode is stack-based, which makes it difficult for program analysis. Java source code, on the other hand, is also not quite suitable for program analysis, due to its nested structures. Therefore, Jimple aims to bring the best of both worlds, a non-stack-based and flat (non-nested) representation. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable. Info To learn more about jimple, refer to the thesis by Raja Vallee-Rai. It might help to visualize how the Jimple version of a Java code looks like. Have a look at the following example on the HelloWorld class. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class HelloWorld extends java.lang.Object { public void <init> () { HelloWorld r0 ; r0 := @this: HelloWorld ; specialinvoke r0 .< java.lang.Object : void <init> ()>(); return ; } public static void main ( java.lang.String []) { java.lang.String[] r0 ; java.io.PrintStream $r1 ; r0 := @parameter0 : java.lang.String []; $r1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $r1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Hello world!\" ); return ; } } 1 2 3 4 5 6 7 8 9 10 11 public class HelloWorld { public HelloWorld () { } public static void main ( String [] var0 ) { System . out . println ( \"Hello World!\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // class version 52.0 (52) // access flags 0x21 public class analysis/HelloWorld { // compiled from: HelloWorld.java // access flags 0x1 public <init>()V L0 LINENUMBER 4 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 6 L1 RETURN L2 LOCALVARIABLE this Lanalysis/HelloWorld; L0 L2 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 9 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Hello World!\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 10 L1 RETURN L2 LOCALVARIABLE var0 [Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"Jimple"},{"location":"jimple/#jimple-grammar-structure","text":"Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.)","title":"Jimple Grammar Structure"},{"location":"jimple/#class-or-interface","text":"A class consists of Fields and Methods. It is referenced by its ClassType. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } } 1 2 3 package target.exercise1 ; public class DemoClass {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 }","title":"Class (or Interface)"},{"location":"jimple/#field","text":"A Field is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : double pi > = 3.14 ; return ; } } /* \"this.<target.exercise1.DemoClass: double pi>\" is JInstanceFieldRef */ 1 2 3 4 5 package target.exercise1 ; public class DemoClass { private final double pi = 3.14 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x12 private final D pi = 3.14 // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 LDC 3.14 PUTFIELD target/exercise1/DemoClass.pi : D RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 }","title":"Field"},{"location":"jimple/#method-and-the-body","text":"The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature and contains a StmtGraph that models the sequence of single instructions/statements (Stmts). Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); virtualinvoke this .< target.exercise1.DemoClass : void demoMethod ()>(); return ; } public void demoMethod () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Inside method.\" ); return ; } } /* \"<target.exercise1.DemoClass: void demoMethod()>\" and \"<target.exercise1.DemoClass: void <init>()>\" are instances of SootMethod */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { DemoClass (){ demoMethod (); } public void demoMethod (){ System . out . println ( \"Inside method.\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x0 <init>()V L0 LINENUMBER 5 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 6 L1 ALOAD 0 INVOKEVIRTUAL target/exercise1/DemoClass.demoMethod ()V L2 LINENUMBER 7 L2 RETURN L3 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L3 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public demoMethod()V L0 LINENUMBER 10 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Inside method.\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 11 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"Method and the Body"},{"location":"jimple/#signatures","text":"Signatures are required for identifying or referencing things across a method, such as Classes, Interfaces, Methods or Fields. Locals, on the other hand, do not need signatures, since they are referenced within method boundaries. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : double pi > = 3.14 ; return ; } public void demoMethod () { java.io.PrintStream $stack3 , $stack5 ; java.lang.StringBuilder $stack4 , $stack6 , $stack7 ; java.lang.String $stack8 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"pi : 3.14\" ); $stack5 = < java.lang.System : java.io.PrintStream out >; $stack4 = new java.lang.StringBuilder ; specialinvoke $stack4 .< java.lang.StringBuilder : void <init> ()>(); $stack6 = virtualinvoke $stack4 .< java.lang.StringBuilder : java.lang.StringBuilder append ( java.lang.String )> ( \"pi : \" ); $stack7 = virtualinvoke $stack6 .< java.lang.StringBuilder : java.lang.StringBuilder append ( double )>( 3.1415 ); $stack8 = virtualinvoke $stack7 .< java.lang.StringBuilder : java.lang.String toString ()>(); virtualinvoke $stack5 .< java.io.PrintStream : void println ( java.lang.String )>( $stack8 ); return ; } } /* For JInstanceFieldRef \"this.<target.exercise1.DemoClass: double pi>\" signature is <target.exercise1.DemoClass: double pi> Similarly, we have other signatures like <java.lang.Object: void <init>()>, <java.io.PrintStream: void println(java.lang.String)> and so on. */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { private final double pi = 3.14 ; public void demoMethod (){ double localPi = 3.1415 ; System . out . println ( \"pi : \" + pi ); System . out . println ( \"pi : \" + localPi ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x12 private final D pi = 3.14 // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 LDC 3.14 PUTFIELD target/exercise1/DemoClass.pi : D RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 // access flags 0x1 public demoMethod()V L0 LINENUMBER 6 L0 LDC 3.1415 DSTORE 1 L1 LINENUMBER 7 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"pi : 3.14\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L2 LINENUMBER 8 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.<init> ()V LDC \"pi : \" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;) Ljava/lang/StringBuilder; DLOAD 1 INVOKEVIRTUAL java/lang/StringBuilder.append (D)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 9 L3 RETURN L4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0 LOCALVARIABLE localPi D L1 L4 1 MAXSTACK = 4 MAXLOCALS = 3 }","title":"Signatures"},{"location":"jimple/#trap","text":"A Trap is a mechanism to model exceptional flow. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void divideExample ( int , int ) { int x , y , $stack4 ; java.io.PrintStream $stack5 , $stack7 ; java.lang.Exception $stack6 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; y := @parameter1 : int ; label1: $stack5 = < java.lang.System : java.io.PrintStream out >; $stack4 = x / y ; virtualinvoke $stack5 .< java.io.PrintStream : void println ( int )>( $stack4 ); label2: goto label4; label3: $stack6 := @caughtexception ; $stack7 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack7 .< java.io.PrintStream : void println ( java.lang.String )>( \"Exception caught\" ); label4: return ; catch java.lang.Exception from label1 to label2 with label3; } } /* By calling getTraps() method, we can get the Traip chain. For the above jimple code, we have the below trap: Trap : begin : $stack5 = <java.lang.System: java.io.PrintStream out> end : goto [?= return] handler: $stack6 := @caughtexception */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { public void divideExample ( int x , int y ){ try { System . out . println ( x / y ); } catch ( Exception e ){ System . out . println ( \"Exception caught\" ); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public divideExample(II)V TRYCATCHBLOCK L0 L1 L2 java/lang/Exception L0 LINENUMBER 6 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 ILOAD 2 IDIV INVOKEVIRTUAL java/io/PrintStream.println (I)V L1 LINENUMBER 9 L1 GOTO L3 L2 LINENUMBER 7 L2 FRAME SAME1 java/lang/Exception ASTORE 3 L4 LINENUMBER 8 L4 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Exception caught\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 10 L3 FRAME SAME RETURN L5 LOCALVARIABLE e Ljava/lang/Exception; L4 L3 3 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE x I L0 L5 1 LOCALVARIABLE y I L0 L5 2 MAXSTACK = 3 MAXLOCALS = 4 }","title":"Trap"},{"location":"jimple/#stmt","text":"The main piece of Jimple is a Statement (Stmt). Stmts represent that can be executed by the JVM.","title":"Stmt"},{"location":"jimple/#branching-statements","text":"A BranchingStmt's job is to model the flow between Stmts.","title":"Branching Statements"},{"location":"jimple/#jgotostmt","text":"for unconditional flow. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public static void sampleMethod () { int i ; i = 0 ; label1: if i >= 5 goto label3; if i != 3 goto label2; goto label3; label2: i = i + 1 ; goto label1; label3: return ; } } /* Here for statements \"goto label3;\" and \"goto label1;\", we have two instances of JGotoStmt : \"goto[?=return]\" and \"goto[?=(branch)]\". */ 1 2 3 4 5 6 7 8 9 10 11 12 package target.exercise1 ; public class DemoClass { public static void sampleMethod (){ label1 : for ( int i = 0 ; i < 5 ; i ++ ){ if ( i == 3 ){ break label1 ; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static sampleMethod()V L0 LINENUMBER 6 L0 ICONST_0 ISTORE 0 L1 FRAME APPEND [I] ILOAD 0 ICONST_5 IF_ICMPGE L2 L3 LINENUMBER 7 L3 ILOAD 0 ICONST_3 IF_ICMPNE L4 L5 LINENUMBER 8 L5 GOTO L2 L4 LINENUMBER 6 L4 FRAME SAME IINC 0 1 GOTO L1 L2 LINENUMBER 11 L2 FRAME CHOP 1 RETURN LOCALVARIABLE i I L1 L2 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"JGotoStmt"},{"location":"jimple/#jifstmt","text":"for conditional flow depending on boolean Expression (AbstractConditionExpr) so they have two successor Stmt's. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public static void sampleMethod ( int ) { int x , $stack1 ; java.io.PrintStream $stack2 , $stack3 ; x := @parameter0 : int ; $stack1 = x % 2 ; if $stack1 != 0 goto label1; $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"Even\" ); goto label2; label1: $stack2 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack2 .< java.io.PrintStream : void println ( java.lang.String )>( \"Odd\" ); label2: return ; } } /* For statement \"if $stack1 != 0 goto label1;\", we have an instance of JIfStmt : \"if $stack1 != 0 goto $stack2 = <java.lang.System:java.io.PrintStream out>\". */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { public static void sampleMethod ( int x ){ if ( x % 2 == 0 ){ System . out . println ( \"Even\" ); } else { System . out . println ( \"Odd\" ); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static sampleMethod(I)V L0 LINENUMBER 5 L0 ILOAD 0 ICONST_2 IREM IFNE L1 L2 LINENUMBER 6 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Even\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V GOTO L3 L1 LINENUMBER 8 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Odd\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 10 L3 FRAME SAME RETURN L4 LOCALVARIABLE x I L0 L4 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"JIfStmt"},{"location":"jimple/#jswitchstmt","text":"for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. All other Stmts are not manipulating the flow, which means they have a single successor Stmt as long as they are not exiting the flow inside a method. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void switchExample ( int ) { int x ; java.io.PrintStream $stack2 , $stack3 , $stack4 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; lookupswitch ( x ) { case 1: goto label1; case 2: goto label2; default : goto label3; }; label1: $stack3 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack3 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input 1\" ); goto label4; label2: $stack2 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack2 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input 2\" ); goto label4; label3: $stack4 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack4 .< java.io.PrintStream : void println ( java.lang.String )>( \"Input more than 2\" ); label4: return ; } } /* Here for below statement: lookupswitch(x) { case 1: goto label1; case 2: goto label2; default: goto label3; }; we have an instance of JLookupSwitchStmt : lookupswitch(x) { case 1: goto $stack3 = <java.lang.System: java.io.PrintStream out>; case 2: goto $stack2 = <java.lang.System: java.io.PrintStream out>; default: goto $stack4 = <java.lang.System: java.io.PrintStream out>; } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package target.exercise1 ; public class DemoClass { public void switchExample ( int x ){ switch ( x ){ case 1 : System . out . println ( \"Input 1\" ); break ; case 2 : System . out . println ( \"Input 2\" ); break ; default : System . out . println ( \"Input more than 2\" ); break ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public switchExample(I)V L0 LINENUMBER 5 L0 ILOAD 1 LOOKUPSWITCH 1: L1 2: L2 default: L3 L1 LINENUMBER 7 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input 1\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L4 LINENUMBER 8 L4 GOTO L5 L2 LINENUMBER 11 L2 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input 2\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L6 LINENUMBER 12 L6 GOTO L5 L3 LINENUMBER 15 L3 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Input more than 2\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L5 LINENUMBER 19 L5 FRAME SAME RETURN L7 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L7 0 LOCALVARIABLE x I L0 L7 1 MAXSTACK = 2 MAXLOCALS = 2 }","title":"JSwitchStmt"},{"location":"jimple/#jreturnstmt-jreturnvoidstmt","text":"They end the execution/flow inside the current method and return (a value) to its caller. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public int increment ( int ) { int x , $stack2 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; $stack2 = x + 1 ; return $stack2 ; } public void print () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Inside method print\" ); return ; } } /* \"return $stack2\" is JReturnStmt. \"return\" is JReturnVoidStmt. */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { public int increment ( int x ){ return x + 1 ; } public void print (){ System . out . println ( \"Inside method print\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public increment(I)I L0 LINENUMBER 5 L0 ILOAD 1 ICONST_1 IADD IRETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE x I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x1 public print()V L0 LINENUMBER 8 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Inside method print\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 9 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"JReturnStmt &amp; JReturnVoidStmt"},{"location":"jimple/#jthrowstmt","text":"Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void divideExample ( int , int ) { int y , x , $stack6 ; java.lang.StringBuilder $stack3 , $stack5 , $stack7 ; java.io.PrintStream $stack4 ; java.lang.String $stack8 ; java.lang.RuntimeException $stack9 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; y := @parameter1 : int ; if y != 0 goto label1; $stack9 = new java.lang.RuntimeException ; specialinvoke $stack9 .< java.lang.RuntimeException : void <init> ( java.lang.String )>( \"Divide by zero error\" ); throw $stack9 ; label1: $stack4 = < java.lang.System : java.io.PrintStream out >; $stack3 = new java.lang.StringBuilder ; specialinvoke $stack3 .< java.lang.StringBuilder : void <init> ()>(); $stack5 = virtualinvoke $stack3 .< java.lang.StringBuilder : java.lang.StringBuilder append ( java.lang.String )>( \"Divide result : \" ); $stack6 = x / y ; $stack7 = virtualinvoke $stack5 .< java.lang.StringBuilder : java.lang.StringBuilder append ( int )>( $stack6 ); $stack8 = virtualinvoke $stack7 .< java.lang.StringBuilder : java.lang.String toString ()>(); virtualinvoke $stack4 .< java.io.PrintStream : void println ( java.lang.String )>( $stack8 ); return ; } } /* \"throw $stack9\" is JThrowStmt. */ 1 2 3 4 5 6 7 8 9 10 package target.exercise1 ; public class DemoClass { public void divideExample ( int x , int y ){ if ( y == 0 ){ throw new RuntimeException ( \"Divide by zero error\" ); } System . out . println ( \"Divide result : \" + x / y ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public divideExample(II)V L0 LINENUMBER 5 L0 ILOAD 2 IFNE L1 L2 LINENUMBER 6 L2 NEW java/lang/RuntimeException DUP LDC \"Divide by zero error\" INVOKESPECIAL java/lang/RuntimeException.<init> (Ljava/lang/String;)V ATHROW L1 LINENUMBER 8 L1 FRAME SAME GETSTATIC java/lang/System.out : Ljava/io/PrintStream; NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.<init> ()V LDC \"Divide result : \" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ILOAD 1 ILOAD 2 IDIV INVOKEVIRTUAL java/lang/StringBuilder.append (I)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 9 L3 RETURN L4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0 LOCALVARIABLE x I L0 L4 1 LOCALVARIABLE y I L0 L4 2 MAXSTACK = 4 MAXLOCALS = 3 }","title":"JThrowStmt"},{"location":"jimple/#jinvokestmt","text":"transfers the control flow to another method until the called method returns. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void print ( int ) { target.exercise1.DemoClass this ; int x , a ; java.io.PrintStream $stack4 , $stack6 ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; a = virtualinvoke this .< target.exercise1.DemoClass : int increment ( int )>( x ); $stack4 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack4 .< java.io.PrintStream : void println ( int )>( a ); a = virtualinvoke this .< target.exercise1.DemoClass : int increment ( int )>( a ); $stack6 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack6 .< java.io.PrintStream : void println ( int )>( a ); return ; } public int increment ( int ) { int x , $stack2 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; x := @parameter0 : int ; $stack2 = x + 1 ; return $stack2 ; } } /* \"specialinvoke this.<java.lang.Object: void <init>()>()\", \"virtualinvoke this.<target.exercise1.DemoClass: int increment(int)>(x)\", \"virtualinvoke this.<target.exercise1.DemoClass: int increment(int)>(a)\" are JInvokeStmts. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 package target.exercise1 ; public class DemoClass { public void print ( int x ){ int a = increment ( x ); System . out . println ( a ); a = increment ( a ); System . out . println ( a ); } public int increment ( int x ){ return x + 1 ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public print(I)V L0 LINENUMBER 5 L0 ALOAD 0 ILOAD 1 INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I ISTORE 2 L1 LINENUMBER 6 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (I)V L2 LINENUMBER 7 L2 ALOAD 0 ILOAD 2 INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I ISTORE 2 L3 LINENUMBER 8 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (I)V L4 LINENUMBER 9 L4 RETURN L5 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE x I L0 L5 1 LOCALVARIABLE a I L1 L5 2 MAXSTACK = 2 MAXLOCALS = 3 // access flags 0x1 public increment(I)I L0 LINENUMBER 11 L0 ILOAD 1 ICONST_1 IADD IRETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE x I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 }","title":"JInvokeStmt"},{"location":"jimple/#jassignstmt","text":"assigns a Value from the right hand-side to the left hand-side. Left hand-side of an assignment can be a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. Right hand-side of an assignment can be an expression (Expr), a Local, a FieldRef or a Constant. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : int counter > = 0 ; return ; } public int updateCounter () { target.exercise1.DemoClass this ; int $stack1 , $stack2 , $stack3 ; this := @this: target.exercise1.DemoClass ; $stack1 = this .< target.exercise1.DemoClass : int counter >; $stack2 = $stack1 + 1 ; this .< target.exercise1.DemoClass : int counter > = $stack2 ; $stack3 = this .< target.exercise1.DemoClass : int counter >; return $stack3 ; } } /* \"this.<target.exercise1.DemoClass: int counter> = 0\", \"$stack1 = this.<target.exercise1.DemoClass: int counter>\", \"$stack2 = $stack1 + 1\" \"this.<target.exercise1.DemoClass: int counter> = $stack2\" \"$stack3 = this.<target.exercise1.DemoClass: int counter>\" are JAssignStmts. */ 1 2 3 4 5 6 7 8 9 package target.exercise1 ; public class DemoClass { private int counter = 0 ; public int updateCounter (){ counter = counter + 1 ; return counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 ICONST_0 PUTFIELD target/exercise1/DemoClass.counter : I RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public updateCounter()I L0 LINENUMBER 6 L0 ALOAD 0 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I ICONST_1 IADD PUTFIELD target/exercise1/DemoClass.counter : I L1 LINENUMBER 7 L1 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I IRETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 3 MAXLOCALS = 1 }","title":"JAssignStmt"},{"location":"jimple/#jidentitystmt","text":"is semantically like the JAssignStmt and handles assignments of IdentityRef's to make implicit assignments explicit into the StmtGraph. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void DemoClass ( int ) { target.exercise1.DemoClass this ; int counter ; this := @this: target.exercise1.DemoClass ; counter := @parameter0 : int ; this .< target.exercise1.DemoClass : int counter > = counter ; return ; } } /* \"this := @this: target.exercise1.DemoClass\" and \"counter := @parameter0: int\" are JIdentityStmts */ 1 2 3 4 5 6 7 8 package target.exercise1 ; public class DemoClass { private int counter ; public void DemoClass ( int counter ){ this . counter = counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public DemoClass(I)V L0 LINENUMBER 6 L0 ALOAD 0 ILOAD 1 PUTFIELD target/exercise1/DemoClass.counter : I L1 LINENUMBER 7 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 LOCALVARIABLE counter I L0 L2 1 MAXSTACK = 2 MAXLOCALS = 2 }","title":"JIdentityStmt"},{"location":"jimple/#jentermonitorstmt-jexitmonitorstmt","text":"marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt. Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); this .< target.exercise1.DemoClass : int counter > = 0 ; return ; } public int updateCounter () { target.exercise1.DemoClass this ; int $stack4 , $stack5 , $stack7 ; java.lang.Throwable $stack8 ; this := @this: target.exercise1.DemoClass ; entermonitor this ; label1: $stack4 = this .< target.exercise1.DemoClass : int counter >; $stack5 = $stack4 + 1 ; this .< target.exercise1.DemoClass : int counter > = $stack5 ; exitmonitor this ; label2: goto label5; label3: $stack8 := @caughtexception ; exitmonitor this ; label4: throw $stack8 ; label5: $stack7 = this .< target.exercise1.DemoClass : int counter >; return $stack7 ; catch java.lang.Throwable from label1 to label2 with label3; catch java.lang.Throwable from label3 to label4 with label3; } } /* \"entermonitor this\" is JEnterMonitorStmt. \"exitmonitor this\" is JExitMonitorStmt. */ 1 2 3 4 5 6 7 8 9 10 11 package target.exercise1 ; public class DemoClass { private int counter = 0 ; public int updateCounter (){ synchronized ( this ) { counter = counter + 1 ; } return counter ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I counter // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V L1 LINENUMBER 4 L1 ALOAD 0 ICONST_0 PUTFIELD target/exercise1/DemoClass.counter : I RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public updateCounter()I TRYCATCHBLOCK L0 L1 L2 null TRYCATCHBLOCK L2 L3 L2 null L4 LINENUMBER 6 L4 ALOAD 0 DUP ASTORE 1 MONITORENTER L0 LINENUMBER 7 L0 ALOAD 0 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I ICONST_1 IADD PUTFIELD target/exercise1/DemoClass.counter : I L5 LINENUMBER 8 L5 ALOAD 1 MONITOREXIT L1 GOTO L6 L2 FRAME FULL [target/exercise1/DemoClass java/lang/Object] [java/lang/Throwable] ASTORE 2 ALOAD 1 MONITOREXIT L3 ALOAD 2 ATHROW L6 LINENUMBER 9 L6 FRAME CHOP 1 ALOAD 0 GETFIELD target/exercise1/DemoClass.counter : I IRETURN L7 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L4 L7 0 MAXSTACK = 3 MAXLOCALS = 3 }","title":"JEnterMonitorStmt &amp; JExitMonitorStmt"},{"location":"jimple/#jretstmt","text":"","title":"JRetStmt"},{"location":"jimple/#jbreakpointstmt","text":"models a Breakpoint set by a Debugger (usually not relevant for static analyses)","title":"JBreakpointStmt"},{"location":"jimple/#immediate","text":"An Immediate has a given Type and consists of a Local (\"a Variable\", \"Something that contains a Value\") or a Constant (\"Something that is a Value\").","title":"Immediate"},{"location":"jimple/#type","text":"VoidType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void voidMethod () { java.io.PrintStream $stack1 ; target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; $stack1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack1 .< java.io.PrintStream : void println ( java.lang.String )>( \"In voidMethod().\" ); return ; } } /* For the SootMethod - <target.exercise1.DemoClass: void voidMethod()>, returnType is instance of VoidType. */ 1 2 3 4 5 6 7 package target.exercise1 ; public class DemoClass { public void voidMethod (){ System . out . println ( \"In voidMethod().\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public voidMethod()V L0 LINENUMBER 5 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"In voidMethod().\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 6 L1 RETURN L2 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 }","title":"Type"},{"location":"jimple/#primarytype","text":"BooleanType, ByteType, CharType, ShortType, IntType, LongType, DoubleType, FloatType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public void display () { java.io.PrintStream $stack11 , $stack13 , $stack15 , $stack17 , $stack19 , $stack21 , $stack23 , $stack25 ; int $stack12 , $stack14 , $stack16 , $stack18 ; long $stack20 ; double $stack22 ; float $stack24 ; target.exercise1.DemoClass this ; boolean $stack26 ; this := @this: target.exercise1.DemoClass ; $stack11 = < java.lang.System : java.io.PrintStream out >; goto label1; label1: $stack26 = 0 ; virtualinvoke $stack11 .< java.io.PrintStream : void println ( boolean )>( $stack26 ); $stack13 = < java.lang.System : java.io.PrintStream out >; $stack12 = 127 - 1 ; virtualinvoke $stack13 .< java.io.PrintStream : void println ( int )>( $stack12 ); $stack15 = < java.lang.System : java.io.PrintStream out >; $stack14 = 97 + 1 ; virtualinvoke $stack15 .< java.io.PrintStream : void println ( int )>( $stack14 ); $stack17 = < java.lang.System : java.io.PrintStream out >; $stack16 = 1123 + 1 ; virtualinvoke $stack17 .< java.io.PrintStream : void println ( int )>( $stack16 ); $stack19 = < java.lang.System : java.io.PrintStream out >; $stack18 = 123456 + 1 ; virtualinvoke $stack19 .< java.io.PrintStream : void println ( int )>( $stack18 ); $stack21 = < java.lang.System : java.io.PrintStream out >; $stack20 = 10L + 1L ; virtualinvoke $stack21 .< java.io.PrintStream : void println ( long )>( $stack20 ); $stack23 = < java.lang.System : java.io.PrintStream out >; $stack22 = 10.1 + 1.0 ; virtualinvoke $stack23 .< java.io.PrintStream : void println ( double )>( $stack22 ); $stack25 = < java.lang.System : java.io.PrintStream out >; $stack24 = 10.1F + 1.0F ; virtualinvoke $stack25 .< java.io.PrintStream : void println ( float )>( $stack24 ); return ; } } /* The JimpleLocal $stack12, $stack14, $stack16, $stack18 are of IntType. Similarly, $stack20 is of LongType, $stack22 is of DoubleType and so on. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package target.exercise1 ; public class DemoClass { public void display (){ boolean varBoolean = true ; byte varByte = 127 ; char varChar = 'a' ; short varShort = 1123 ; int varInt = 123456 ; long varLong = 10L ; double varDouble = 10.10 ; float varFloat = 10.10f ; System . out . println ( ! varBoolean ); System . out . println ( varByte - 1 ); System . out . println ( varChar + 1 ); System . out . println ( varShort + 1 ); System . out . println ( varInt + 1 ); System . out . println ( varLong + 1 ); System . out . println ( varDouble + 1 ); System . out . println ( varFloat + 1 ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public display()V L0 LINENUMBER 5 L0 ICONST_1 ISTORE 1 L1 LINENUMBER 6 L1 BIPUSH 127 ISTORE 2 L2 LINENUMBER 7 L2 BIPUSH 97 ISTORE 3 L3 LINENUMBER 8 L3 SIPUSH 1123 ISTORE 4 L4 LINENUMBER 9 L4 LDC 123456 ISTORE 5 L5 LINENUMBER 10 L5 LDC 10 LSTORE 6 L6 LINENUMBER 11 L6 LDC 10.1 DSTORE 8 L7 LINENUMBER 12 L7 LDC 10.1 FSTORE 10 L8 LINENUMBER 14 L8 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 IFNE L9 ICONST_1 GOTO L10 L9 FRAME FULL [target/exercise1/DemoClass I I I I I J D F] [java/io/PrintStream] ICONST_0 L10 FRAME FULL [target/exercise1/DemoClass I I I I I J D F] [java/io/PrintStream I] INVOKEVIRTUAL java/io/PrintStream.println (Z)V L11 LINENUMBER 15 L11 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 2 ICONST_1 ISUB INVOKEVIRTUAL java/io/PrintStream.println (I)V L12 LINENUMBER 16 L12 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 3 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L13 LINENUMBER 17 L13 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 4 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L14 LINENUMBER 18 L14 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 5 ICONST_1 IADD INVOKEVIRTUAL java/io/PrintStream.println (I)V L15 LINENUMBER 19 L15 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LLOAD 6 LCONST_1 LADD INVOKEVIRTUAL java/io/PrintStream.println (J)V L16 LINENUMBER 20 L16 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; DLOAD 8 DCONST_1 DADD INVOKEVIRTUAL java/io/PrintStream.println (D)V L17 LINENUMBER 21 L17 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; FLOAD 10 FCONST_1 FADD INVOKEVIRTUAL java/io/PrintStream.println (F)V L18 LINENUMBER 23 L18 RETURN L19 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L19 0 LOCALVARIABLE varBoolean Z L1 L19 1 LOCALVARIABLE varByte B L2 L19 2 LOCALVARIABLE varChar C L3 L19 3 LOCALVARIABLE varShort S L4 L19 4 LOCALVARIABLE varInt I L5 L19 5 LOCALVARIABLE varLong J L6 L19 6 LOCALVARIABLE varDouble D L7 L19 8 LOCALVARIABLE varFloat F L8 L19 10 MAXSTACK = 5 MAXLOCALS = 11 }","title":"PrimaryType"},{"location":"jimple/#referencetype","text":"ClassType, ArrayType NullType Jimple Java Byte Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class target.exercise1.DemoClass extends java.lang.Object { public void <init> () { target.exercise1.DemoClass this ; this := @this: target.exercise1.DemoClass ; specialinvoke this .< java.lang.Object : void <init> ()>(); return ; } public target.exercise1.DemoClass getObject ( target.exercise1.DemoClass ) { target.exercise1.DemoClass obj , this ; this := @this: target.exercise1.DemoClass ; obj := @parameter0 : target.exercise1.DemoClass ; return obj ; } public void compute ( boolean ) { int[] b ; java.io.PrintStream $stack5 , $stack6 ; boolean check ; target.exercise1.DemoClass this ; int i ; null_type $r0 ; java.lang.NullPointerException soot0 ; this := @this: target.exercise1.DemoClass ; check := @parameter0 : boolean ; b = newarray ( int )[5]; i = 0 ; label1: if i >= 5 goto label3; if check == 0 goto label2; $r0 = ( null_type ) i ; soot0 = new java.lang.NullPointerException ; specialinvoke soot0 .< java.lang.NullPointerException : void <init> ( java.lang.String )> ( \"This statement would have triggered an Exception: a[i#1] = $r0\" ); throw soot0 ; label2: b [ i ] = i ; i = i + 1 ; goto label1; label3: $stack5 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack5 .< java.io.PrintStream : void println ( java.lang.Object )>( b ); $stack6 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $stack6 .< java.io.PrintStream : void println ( java.lang.Object )>( null ); return ; } } /* The JimpleLocal b is of ArrayType, and JimpleLocal $r0 is of NullType. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package target.exercise1 ; public class DemoClass { public DemoClass getObject ( DemoClass obj ){ return obj ; } public void compute ( boolean check ){ int a [] = null ; int b [] = new int [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( check ){ a [ i ] = i ; } b [ i ] = i ; } System . out . println ( b ); System . out . println ( a ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public getObject(Ltarget/exercise1/DemoClass;)Ltarget/exercise1/DemoClass; L0 LINENUMBER 6 L0 ALOAD 1 ARETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 LOCALVARIABLE obj Ltarget/exercise1/DemoClass; L0 L1 1 MAXSTACK = 1 MAXLOCALS = 2 // access flags 0x1 public compute(Z)V L0 LINENUMBER 10 L0 ACONST_NULL ASTORE 2 L1 LINENUMBER 11 L1 ICONST_5 NEWARRAY T_INT ASTORE 3 L2 LINENUMBER 12 L2 ICONST_0 ISTORE 4 L3 FRAME APPEND [[I [I I] ILOAD 4 ICONST_5 IF_ICMPGE L4 L5 LINENUMBER 13 L5 ILOAD 1 IFEQ L6 L7 LINENUMBER 14 L7 ALOAD 2 ILOAD 4 ILOAD 4 IASTORE L6 LINENUMBER 16 L6 FRAME SAME ALOAD 3 ILOAD 4 ILOAD 4 IASTORE L8 LINENUMBER 12 L8 IINC 4 1 GOTO L3 L4 LINENUMBER 18 L4 FRAME CHOP 1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 3 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L9 LINENUMBER 19 L9 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L10 LINENUMBER 20 L10 RETURN L11 LOCALVARIABLE i I L3 L4 4 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L11 0 LOCALVARIABLE check Z L0 L11 1 LOCALVARIABLE a [I L1 L11 2 LOCALVARIABLE b [I L2 L11 3 MAXSTACK = 3 MAXLOCALS = 5 }","title":"ReferenceType"},{"location":"jimple/#local","text":"jimple $i0 A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt. Jimple Java Byte Code ```jimple public class target.exercise1.DemoClass extends java.lang.Object { public void () { target.exercise1.DemoClass this; this := @this: target.exercise1.DemoClass; specialinvoke this. ()>(); return; } public void compute() { java.io.PrintStream $stack2, $stack3; target.exercise1.DemoClass this; int local#2; 1 2 3 4 5 6 7 8 this := @this: target.exercise1.DemoClass; $stack2 = <java.lang.System: java.io.PrintStream out>; virtualinvoke $stack2.<java.io.PrintStream: void println(int)>(1); local#2 = this.<target.exercise1.DemoClass: int global>; $stack3 = <java.lang.System: java.io.PrintStream out>; virtualinvoke $stack3.<java.io.PrintStream: void println(int)>(local#2); return; } } /* $stack2, this, $stack3, local#2 are all JimpleLocal. \"this := @this: target.exercise1.DemoClass\" is JIdentityStmt \"$stack2 = \", \"local#2 = this. \", \"$stack3 = \" are JAssignStmt */ ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package target.exercise1 ; public class DemoClass { private int global ; public void compute (){ int local ; local = 1 ; System . out . println ( local ); local = this . global ; System . out . println ( local ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // class version 52.0 (52) // access flags 0x21 public class target/exercise1/DemoClass { // compiled from: DemoClass.java // access flags 0x2 private I global // access flags 0x1 public <init>()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.<init> ()V RETURN L1 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public compute()V L0 LINENUMBER 9 L0 ICONST_1 ISTORE 1 L1 LINENUMBER 10 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (I)V L2 LINENUMBER 11 L2 ALOAD 0 GETFIELD target/exercise1/DemoClass.global : I ISTORE 1 L3 LINENUMBER 12 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (I)V L4 LINENUMBER 14 L4 RETURN L5 LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0 LOCALVARIABLE local I L1 L5 1 MAXSTACK = 2 MAXLOCALS = 2 }","title":"Local"},{"location":"jimple/#constant","text":"represents a value itself. don't confuse it with a variable/Local which has a immutable (i.e. final) attribute. There exists a constant entity for every Type - that way all value types can have a representation.","title":"Constant"},{"location":"jimple/#expr","text":"An expression is a language construct that returns a value. E.g. a binary operation such as addition.","title":"Expr"},{"location":"jimple/#ref","text":"","title":"Ref"},{"location":"jimple/#jarrayref","text":"jimple $arr[1] referencing a position inside an array.","title":"JArrayRef"},{"location":"jimple/#jfieldref-jstaticfieldref-jinstancefieldref","text":"jimple <SomePackage.ExampleClass: fieldname> // or $r1.<SomePackage.ExampleClass: fieldname> referencing a Field via its FieldSignature and if necessary (i.e. with JInstanceFieldRef) the corresponding Local instance that points to the object instance.","title":"JFieldRef (JStaticFieldRef &amp; JInstanceFieldRef)"},{"location":"jimple/#identityref","text":"The IdentityRef makes those implicit special value assignments explicit.","title":"IdentityRef"},{"location":"jimple/#jthisref","text":"jimple @this: package.fruit.Banana represents the this pointer of the current class.","title":"JThisRef"},{"location":"jimple/#jcaughtexceptionref","text":"jimple @caughtexception represents the value of the thrown exception (caught by this exceptionhandler).","title":"JCaughtExceptionRef"},{"location":"jimple/#jparameterref","text":"jimple $i0 := @parameter0 $i1 := @parameter1 represents a parameter of a method, identified by its index.","title":"JParameterRef"},{"location":"tools/","text":"","title":"Tools"}]}